var c=(s="",t={})=>{throw new Error(`[joystick${s?`.${s}`:""}] ${t.message||t.reason||t}`)};var o=s=>{try{return typeof s=="function"}catch(t){c("types.isFunction",t)}};var h=s=>{try{return!!(s&&typeof s=="object"&&!Array.isArray(s))}catch(t){c("types.isObject",t)}};var p=class{constructor(t="",e={}){this.name=t,this.value=e||{},this.listeners={change:[],set:[],unset:[]}}_getValueAtPath(t=""){return t?.split(".").reduce((e=null,r="")=>(e[r]&&(e=e[r]),e),this.value)}get(t=""){return t?.trim()===""?{...this.value||{}}:this._getValueAtPath(t)}set(t=null,e=""){if(!t||!o(t))throw new Error("First argument passed to set() must be a function.");let r=t(this.value);if(!h(r))throw new Error("Value to set must be an object representing the current cache state.");this.value=r,this._handleEvent(e,"set"),this._handleEvent(e,"change")}unset(t="",e=""){t?.trim()===""&&(this.value={});let r=t?.split("."),n=r?.length-1;r.reduce((i,u,a)=>(a===n&&delete i[u],i[u]),this.value),this._handleEvent(e,"unset"),this._handleEvent(e,"change")}on(t="",e=null){if(!["change","set","unset"].includes(t))throw new Error(`Event to listen for must be change, set, or unset. ${t} is not supported.`);if(!e||!o(e))throw new Error("Second argument passed to on("<t>") must be a function.");this.listeners={[t]:[...this.listeners[t]||[],e]}}_handleEvent(t="",e=""){let r=this.listeners[e]||[];for(let n=0;n<r?.length;n+=1){let i=r[n];o(i)&&i(this.value,t,e)}}},d=p;export{d as default};
