var n=(r="",t={})=>{throw new Error(`[joystick${r?`.${r}`:""}] ${t.message||t.reason||t}`)};var c=r=>{try{return typeof r=="function"}catch(t){n("types.isFunction",t)}};var u=r=>{try{return!!(r&&typeof r=="object"&&!Array.isArray(r))}catch(t){n("types.isObject",t)}};var p=r=>{try{return typeof r=="string"}catch(t){n("types.isString",t)}};var a=class{constructor(t="",e={}){this.name=t,this.value=e||{},this.listeners={change:[],set:[],unset:[]}}_getValueAtPath(t=""){return t?.split(".").reduce((e=null,s="")=>(e[s]&&(e=e[s]),e),this.value)}get(t=""){return t?.trim()===""?{...this.value||{}}:this._getValueAtPath(t)}set(t=null,e=""){if(!t||!c(t))throw new Error("First argument passed to set() must be a function.");let s=t(this.value);if(!u(s))throw new Error("Value to set must be an object representing the current cache state.");this.value=s,this._handleEvent(e,"set"),this._handleEvent(e,"change")}unset(t="",e=""){t?.trim()===""&&(this.value={});let s=t?.split("."),o=s?.length-1;s.reduce((i,h,l)=>(l===o&&delete i[h],i[h]),this.value),this._handleEvent(e,"unset"),this._handleEvent(e,"change")}on(t="",e=null){if(!["change","set","unset"].includes(t))throw new Error(`Event to listen for must be change, set, or unset. ${t} is not supported.`);if(!e||!c(e))throw new Error("Second argument passed to on("<t>") must be a function.");this.listeners={[t]:[...this.listeners[t]||[],e]}}_handleEvent(t="",e=""){let s=this.listeners[e]||[];for(let o=0;o<s?.length;o+=1){let i=s[o];c(i)&&i(this.value,t,e)}}},y=a;var A=(r="",t={})=>{try{if(!r||r&&!p(r))throw new Error("Must pass a cache name as a string.");if(t&&!u(t))throw new Error("Default value for cache must be an object.");return new y(r,t)}catch(e){n("cache",e)}};export{A as default};
