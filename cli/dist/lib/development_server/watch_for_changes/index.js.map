{
  "version": 3,
  "sources": ["../../../../src/lib/development_server/watch_for_changes/index.js"],
  "sourcesContent": ["import chokidar from 'chokidar';\nimport fs from 'fs';\nimport { dirname } from 'path';\nimport build_files from '../../build/build_files.js';\nimport debounce from '../../debounce.js';\nimport get_after_run_tasks from './get_after_run_tasks.js';\nimport get_file_codependencies from './get_file_codependencies.js';\nimport get_file_operation from '../../build/get_file_operation.js';\nimport get_path_platform from '../../build/get_path_platform.js';\nimport types from '../../types.js';\nimport watch_paths from './watch_paths.js';\n \nconst { mkdir, copyFile, rm: remove } = fs.promises;\n\nconst handle_build_files = async (job = {}, options = {}) => {\n\tconst codependencies = process.initial_build_complete ? await get_file_codependencies(job?.path) : [];\n\n\tconsole.log(job);\n\t// NOTE: If we have codependencies, make sure that the file triggering the current job is rebuilt first\n\t// *before* rebuilding its codependencies. This ensures that codependencies get the latest build of the\n\t// file. If we do them all together in parallel, the latest build is missed.\n\tif (options?.is_build_file) {\n\t\tawait build_files({\n\t\t\tfiles: [{ path: job?.path, platform: get_path_platform(job?.path) }],\n\t\t}).catch((errors = []) => {\n\t\t\tif (!process.initial_build_complete && errors?.length > 0) {\n\t\t\t\tprocess.exit(0);\n\t\t\t}\n\n\t\t\tif (process.initial_build_complete && errors?.length > 0) {\n\t\t\t\tprocess.app_server_process.send(\n\t        JSON.stringify({\n\t          type: \"BUILD_ERROR\",\n\t          paths: errors.filter(({ success }) => !success),\n\t        })\n\t      );\n\t\t\t\t\n\t\t\t\tprocess.hmr_server_process.send(JSON.stringify({\n\t\t\t    type: 'BUILD_ERROR',\n\t\t\t  }));\n\n\t\t\t\tthrow new Error('BUILD_ERROR');\n\t\t\t}\n\t\t});\n\t}\n\n\t// NOTE: Run handle_build_files() recursively against codependencies as each of *that* files codependencies\n\t// need to be rebuilt, too. This is because we bundle code into a single file, so all files up the \"tree\"\n\t// need to be updated to reflect any changes of their children.\n\tif (codependencies?.length > 0) {\n\t\tfor (let i = 0; i < codependencies?.length; i += 1) {\n\t\t\tconst codependency = codependencies[i];\n\t\t\tawait handle_build_files({ path: codependency }, options);\n\t\t}\n\t}\n\n\treturn Promise.resolve();\n};\n\nconst run_job = async (job = {}) => {\n\tswitch(job?.operation) {\n\t\tcase 'add_directory':\n\t\t\treturn mkdir(`.joystick/build/${job?.path}`, { recursive: true });\n\t\tcase 'build_file':\n\t\t\treturn handle_build_files(job, { is_build_file: true });\n\t\tcase 'copy_file':\n\t\t\tawait mkdir(dirname(`.joystick/build/${job?.path}`), { recursive: true });\n\t\t\tawait copyFile(job?.path, `.joystick/build/${job?.path}`);\n\t\t\treturn handle_build_files(job, { is_build_file: false });\n\t\tcase 'delete_directory':\n\t\t\treturn remove(`.joystick/build/${job?.path}`, { recursive: true });\n\t\tcase 'delete_file':\n\t\t\tawait remove(`.joystick/build/${job?.path}`, { recursive: true });\n\t\t\treturn handle_build_files(job, { is_build_file: false });\n\t\tdefault:\n\t\t\treturn true;\n\t}\n};\n\nconst get_delete_directory_job = (job = {}) => {\n\treturn {\n\t\toperation: job?.event,\n\t\tpath: job?.path,\n\t\tafter_run_tasks: process.initial_build_complete ? get_after_run_tasks(job?.path) : ['start_app_server', 'start_hmr_server'],\n\t};\n};\n\nconst get_add_directory_job = (job = {}) => {\n\treturn {\n\t\toperation: job?.event,\n\t\tpath: job?.path,\n\t\tafter_run_tasks: process.initial_build_complete ? get_after_run_tasks(job?.path) : ['start_app_server', 'start_hmr_server'],\n\t};\n};\n\nconst get_delete_file_job = (job = {}) => {\n\treturn {\n\t\toperation: job?.event,\n\t\tpath: job?.path,\n\t\tafter_run_tasks: process.initial_build_complete ? get_after_run_tasks(job?.path) : ['start_app_server', 'start_hmr_server'],\n\t};\n};\n\nconst get_change_file_job = (job = {}) => {\n\treturn {\n\t\toperation: job?.is_custom_copy_path ? 'copy_file' : get_file_operation(job?.path),\n\t\tpath: job?.path,\n\t\tafter_run_tasks: process.initial_build_complete ? get_after_run_tasks(job?.path) : ['start_app_server', 'start_hmr_server'],\n\t};\n};\n\nconst get_add_file_job = (job = {}) => {\n\treturn {\n\t\toperation: job?.is_custom_copy_path ? 'copy_file' : get_file_operation(job?.path),\n\t\tpath: job?.path,\n\t\tafter_run_tasks: process.initial_build_complete ? get_after_run_tasks(job?.path) : ['start_app_server', 'start_hmr_server'],\n\t};\n};\n\nconst get_job_to_be_done = (job = {}) => {\n\tswitch(job?.event) {\n\t\tcase 'add_file':\n\t\t\treturn get_add_file_job(job);\n\t\tcase 'change_file':\n\t\t\treturn get_change_file_job(job);\n\t\tcase 'delete_file':\n\t\t\treturn get_delete_file_job(job);\n\t\tcase 'add_directory':\n\t\t\treturn get_add_directory_job(job);\n\t\tcase 'delete_directory':\n\t\t\treturn get_delete_directory_job(job);\n\t}\n};\n\nconst process_file_watcher_jobs = async (jobs = [], after_run_functions = {}) => {\n\ttry {\n\t\tconst after_run_tasks = new Set([]);\n\n\t\tfor (let i = 0; i < jobs?.length; i += 1) {\n\t\t\tconst job_to_run = jobs[i];\n\t\t\tconst job = get_job_to_be_done(job_to_run);\n\n\t\t\tawait run_job(job);\n\n\t\t\tif (job?.after_run_tasks) {\n\t\t\t\tfor (let i = 0; i < job?.after_run_tasks?.length; i += 1) {\n\t\t\t\t\tconst after_run_task = job?.after_run_tasks[i];\n\t\t\t\t\tafter_run_tasks.add(after_run_task);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst tasks_to_run = Array.from(after_run_tasks);\n\n\t\tfor (let i = 0; i < tasks_to_run?.length; i += 1) {\n\t\t\tconst after_run_task = tasks_to_run[i];\n\n\t\t\tif (types.is_function(after_run_functions[after_run_task])) {\n\t\t\t\tawait after_run_functions[after_run_task](jobs);\n\t\t\t}\n\t\t}\n\t} catch(error) {\n\t\t// NOTE: Dead catch as we just want to avoid after_run_tasks from running. Actual\n\t\t// errors are handled as part of run_job() (e.g., build errors are handled as a part\n\t\t// of handle_build_files()).\n\t}\n};\n\nconst transform_chokidar_event = (event = '') => {\n\tswitch(event) {\n\t\tcase 'add':\n\t\t\treturn 'add_file';\n\t\tcase 'change':\n\t\t\treturn 'change_file';\n\t\tcase 'unlink':\n\t\t\treturn 'delete_file';\n\t\tcase 'addDir':\n\t\t\treturn 'add_directory';\n\t\tcase 'unlinkDir':\n\t\t\treturn 'delete_directory';\n\t}\n};\n\nconst watch_for_changes = (after_run_functions = {}, watch_for_changes_options = {}) => {\n\tconst file_watcher = chokidar.watch([...watch_paths, ...(watch_for_changes_options?.custom_copy_paths || [])].map(({ path }) => path), {\n\t\tignored: '.joystick',\n\t});\n\n\tlet file_watcher_jobs = [];\n\n\tprocess.initial_build_complete = false;\n\n\tfile_watcher.on('error', (error) => console.error(error));\n\n\tfile_watcher.on('all', (event, path) => {\n\t\tconst is_excluded_path = watch_for_changes_options?.excluded_paths?.some((excluded_path) => {\n\t\t\treturn path.includes(excluded_path);\n\t\t});\n\n\t\tif (!is_excluded_path) {\n\t\t\tfile_watcher_jobs.push({\n\t\t\t\tevent: transform_chokidar_event(event),\n\t\t\t\tpath,\n\t\t\t\tis_custom_copy_path: watch_for_changes_options?.custom_copy_paths?.length ? watch_for_changes_options?.custom_copy_paths.some((custom_copy_path) => {\n\t\t\t\t  return path.includes(custom_copy_path?.path);\n\t\t\t\t}) : false,\n\t\t\t});\n\n\t\t\t// NOTE: Depending on the watch event, we expect multiple events to be emitted\n\t\t\t// by chokidar. Debouncing here allows us to \"collect\" the jobs for the current\n\t\t\t// chain of events and *then* process them all together. This is done to avoid\n\t\t\t// triggering multiple HMR calls or server restarts for files related to the\n\t\t\t// same job. This is near-instant, so there's no delay for the developer.\n\t\t\tdebounce(async () => {\n\t\t\t\tawait process_file_watcher_jobs(file_watcher_jobs, after_run_functions);\n\t\t\t\tprocess.initial_build_complete = true;\n\t\t\t\tfile_watcher_jobs = [];\n\t\t\t}, 100);\n\t\t}\n\t});\n};\n\nexport default watch_for_changes;\n"],
  "mappings": "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",
  "names": ["chokidar", "fs", "dirname", "build_files", "debounce", "get_after_run_tasks", "get_file_codependencies", "get_file_operation", "get_path_platform", "types", "watch_paths", "mkdir", "copyFile", "remove", "handle_build_files", "job", "options", "codependencies", "errors", "success", "i", "codependency", "run_job", "get_delete_directory_job", "get_add_directory_job", "get_delete_file_job", "get_change_file_job", "get_add_file_job", "get_job_to_be_done", "process_file_watcher_jobs", "jobs", "after_run_functions", "after_run_tasks", "job_to_run", "after_run_task", "tasks_to_run", "transform_chokidar_event", "event", "watch_for_changes", "watch_for_changes_options", "file_watcher", "path", "file_watcher_jobs", "error", "excluded_path", "custom_copy_path", "index_default"]
}
