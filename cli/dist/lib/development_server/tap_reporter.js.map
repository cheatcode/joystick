{
  "version": 3,
  "sources": ["../../../src/lib/development_server/tap_reporter.js"],
  "sourcesContent": ["// tap_reporter.js\n// NOTE: Run with: ava --tap | node tap_reporter.js\n\nconst green = (s) => `\\x1b[32m${s}\\x1b[0m`;\nconst red = (s) => `\\x1b[31m${s}\\x1b[0m`;\nconst gray = (s) => `\\x1b[90m${s}\\x1b[0m`;\n\nconst parse_title = (line) => {\n  const ok_match = line.match(/^ok\\s+\\d+\\s+(.*)$/);\n  if (ok_match)\n    return { status: 'ok', title: ok_match[1].trim().replace(/^- /, '') };\n  const not_ok_match = line.match(/^not ok\\s+\\d+\\s+(.*)$/);\n  if (not_ok_match)\n    return {\n      status: 'not_ok',\n      title: not_ok_match[1].trim().replace(/^- /, ''),\n    };\n  return null;\n};\n\nconst print_pass = (title) => {\n  process.stdout.write(`${green('\u2714')} ${title}\\n`);\n};\n\nconst print_fail = (title, detail) => {\n  process.stdout.write(`\\n${red('-!-')}\\n`);\n  process.stdout.write(`\\n${red('\u2716')} ${title}\\n\\n`);\n  process.stdout.write(`${red('Error:')}\\n\\n`);\n  if (detail && detail.trim()) {\n    process.stdout.write(`  ${detail.trim()}\\n\\n`);\n  } else {\n    process.stdout.write(`  (no stack trace)\\n\\n`);\n  }\n  process.stdout.write(`${red('-!-')}\\n\\n`);\n};\n\nconst get_indent = (s) => s.match(/^ */)?.[0].length ?? 0;\n\nconst read_block_after_key = (lines, key_idx, key_indent_len) => {\n  const out = [];\n  const base = key_indent_len + 2;\n  for (let i = key_idx + 1; i < lines.length; i += 1) {\n    const l = lines[i];\n    if (l.trim() === '...') break;\n    if (get_indent(l) < base) break;\n    out.push(l.slice(base));\n  }\n  return out.join('\\n');\n};\n\nconst find_key = (lines, key, start = 0) => {\n  for (let i = start; i < lines.length; i += 1) {\n    const m = lines[i].match(/^(\\s*)([A-Za-z0-9_-]+)\\s*:\\s*(\\|>?-?)?\\s*(.*)$/);\n    if (!m) continue;\n    const [, indent_s, k, blocky, rest] = m;\n    if (k !== key) continue;\n    const indent_len = indent_s.length;\n    if (blocky) return { idx: i, type: 'block', indent_len };\n    if (rest && rest.trim())\n      return { idx: i, type: 'inline', value: rest.trim(), indent_len };\n    return { idx: i, type: 'block', indent_len };\n  }\n  return null;\n};\n\nconst extract_error_stack = (diag_lines) => {\n  const lines = diag_lines.map((l) => l.replace(/\\r$/, ''));\n\n  const error_key = find_key(lines, 'error', 0);\n  if (error_key) {\n    const err_indent = error_key.indent_len + 2;\n    for (let i = error_key.idx + 1; i < lines.length; i += 1) {\n      const l = lines[i];\n      if (l.trim() === '...') break;\n      if (get_indent(l) < err_indent) break;\n\n      const m = l.match(/^(\\s*)(stack)\\s*:\\s*(\\|>?-?)?\\s*(.*)$/);\n      if (m) {\n        const [, key_indent_s, , blocky, rest] = m;\n        const key_indent_len = key_indent_s.length;\n        if (blocky) return read_block_after_key(lines, i, key_indent_len);\n        if (rest && rest.trim()) return rest.trim();\n        return read_block_after_key(lines, i, key_indent_len);\n      }\n    }\n  }\n\n  const top_stack = find_key(lines, 'stack', 0);\n  if (top_stack) {\n    if (top_stack.type === 'inline') return top_stack.value;\n    return read_block_after_key(lines, top_stack.idx, top_stack.indent_len);\n  }\n\n  const frame_lines = [];\n  let started = false;\n  for (let i = 0; i < lines.length; i += 1) {\n    const l = lines[i];\n    if (/^\\s*at\\s+.+\\:\\d+\\:\\d+\\)?$/.test(l)) {\n      started = true;\n      frame_lines.push(l.trim());\n      continue;\n    }\n    if (started) {\n      if (/^\\s*at\\s+/.test(l)) {\n        frame_lines.push(l.trim());\n      } else {\n        break;\n      }\n    }\n  }\n  if (frame_lines.length) return frame_lines.join('\\n');\n\n  const msg_key = find_key(lines, 'message', 0);\n  if (msg_key) {\n    if (msg_key.type === 'inline') return msg_key.value;\n    return read_block_after_key(lines, msg_key.idx, msg_key.indent_len);\n  }\n\n  return '';\n};\n\nconst start_ns = process.hrtime.bigint();\n\nconst run_tap_reporter = async () => {\n  let buffer = '';\n  let passed = 0;\n  let failed = 0;\n\n  let pending_fail = null;\n  let in_diag = false;\n  let diag_lines = [];\n\n  const handle_line = (raw_line) => {\n    const line = raw_line.replace(/\\r$/, '');\n    if (!line) return;\n\n    if (in_diag) {\n      if (line.trim() === '...') {\n        const stack = extract_error_stack(diag_lines);\n        print_fail(pending_fail?.title || '(unknown)', stack);\n        failed += 1;\n        pending_fail = null;\n        in_diag = false;\n        diag_lines = [];\n        return;\n      }\n      diag_lines.push(line);\n      return;\n    }\n\n    if (/^\\s*---\\s*$/.test(line) && pending_fail) {\n      in_diag = true;\n      diag_lines = [];\n      return;\n    }\n\n    const parsed = parse_title(line);\n    if (parsed) {\n      if (parsed.status === 'ok') {\n        passed += 1;\n        print_pass(parsed.title);\n      } else if (parsed.status === 'not_ok') {\n        pending_fail = { title: parsed.title };\n      }\n      return;\n    }\n  };\n\n  process.stdin.setEncoding('utf8');\n  process.stdin.on('data', (chunk) => {\n    buffer += chunk;\n    const parts = buffer.split('\\n');\n    buffer = parts.pop() || '';\n    for (const part of parts) handle_line(part);\n  });\n\n  process.stdin.on('end', () => {\n    if (pending_fail) {\n      const stack = extract_error_stack(diag_lines);\n      print_fail(pending_fail.title, stack);\n      failed += 1;\n      pending_fail = null;\n    }\n    const end_ns = process.hrtime.bigint();\n    const duration_ms = Number(end_ns - start_ns) / 1e6;\n    const duration_str =\n      duration_ms < 1000\n        ? `${duration_ms.toFixed(0)} ms`\n        : duration_ms < 60000\n        ? `${(duration_ms / 1000).toFixed(2)} s`\n        : `${Math.floor(duration_ms / 60000)}m ${(\n            (duration_ms % 60000) /\n            1000\n          ).toFixed(2)}s`;\n\n    process.stdout.write(\n      `\\n${gray('===')}\\n\\n${green('Passed:')} ${passed}\\n${red(\n        'Failed:'\n      )} ${failed}\\n${gray('Duration:')} ${duration_str}\\n\\n`\n    );\n  });\n};\n\nexport default run_tap_reporter;\n\nif (import.meta.url === `file://${process.argv[1]}`) {\n  run_tap_reporter();\n}\n"],
  "mappings": "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",
  "names": ["green", "s", "red", "gray", "parse_title", "line", "ok_match", "not_ok_match", "print_pass", "title", "print_fail", "detail", "get_indent", "read_block_after_key", "lines", "key_idx", "key_indent_len", "out", "base", "i", "l", "find_key", "key", "start", "m", "indent_s", "k", "blocky", "rest", "indent_len", "extract_error_stack", "diag_lines", "error_key", "err_indent", "key_indent_s", "top_stack", "frame_lines", "started", "msg_key", "start_ns", "run_tap_reporter", "buffer", "passed", "failed", "pending_fail", "in_diag", "handle_line", "raw_line", "stack", "parsed", "chunk", "parts", "part", "end_ns", "duration_ms", "duration_str", "tap_reporter_default"]
}
