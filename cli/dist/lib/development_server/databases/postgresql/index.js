import l from"child_process";import L from"fs";import S from"util";import j from"os";import $ from"path";import P from"../../../get_platform_safe_path.js";import x from"../../../get_process_id_from_port.js";import b from"../../../path_exists.js";import Q from"../../../get_architecture.js";const s=S.promisify(l.exec),{rename:I}=L.promises,v=async(o=2610)=>{const c=await b(".joystick/data/postgresql");let n=await b(`.joystick/data/postgresql_${o}`);return c&&!n&&(await I(".joystick/data/postgresql",`.joystick/data/postgresql_${o}`),n=!0),n},D=()=>process.platform==="win32"?"createdb.exe":"createdb",R=()=>process.platform==="win32"?"postgres.exe":"postgres",K=()=>process.platform==="win32"?"initdb.exe":"initdb",E=()=>process.platform==="win32"?"pgctl.exe":"pgctl",z=()=>process.platform==="linux"&&process.getuid&&process.getuid()===0?"su postgres -c":"",A=async(o=2610)=>{try{const c=o,n=Q(),w=$.join(j.homedir(),".joystick","databases","postgresql",n),r=$.join(w,"bin"),y=E(),f=K(),m=R(),u=D(),e=z();if(!await v(o))if(e){try{await s("id postgres")}catch{await s("useradd -r -s /bin/false postgres")}await s(`mkdir -p ${process.cwd()}/.joystick/data/postgresql_${o}`,{cwd:process.cwd()}),await s(`mkdir -p ${process.cwd()}/.joystick/data`,{cwd:process.cwd()}),await s(`chmod 755 ${process.cwd()}`,{cwd:process.cwd()}),await s(`chmod 755 ${process.cwd()}/.joystick`,{cwd:process.cwd()}),await s(`chmod 755 ${process.cwd()}/.joystick/data`,{cwd:process.cwd()}),await s(`chown -R postgres:postgres ${process.cwd()}/.joystick/data/postgresql_${o}`,{cwd:process.cwd()}),await s(`chmod 755 ${j.homedir()}`,{cwd:process.cwd()}),await s(`chmod -R 755 ${$.dirname(w)}`,{cwd:process.cwd()}),await s(`chown -R postgres:postgres ${w}`,{cwd:process.cwd()});const a=`${e} "cd ${r} && ./${f} -D ${process.cwd()}/.joystick/data/postgresql_${o} --no-locale"`;await s(a,{cwd:process.cwd()})}else await s(`./${f} -D ${process.cwd()}/.joystick/data/postgresql_${o} --no-locale`,{cwd:r});const _=parseInt(await x(c),10);if(_)if(e){const a=`${e} "cd ${r} && ./${y} kill KILL ${_}"`;await s(a,{cwd:process.cwd()})}else await s(`./${y} kill KILL ${_}`,{cwd:r});const h=[`-p ${c}`,"-D",P(`${process.cwd()}/.joystick/data/postgresql_${o}`)];if(e){const a=`${e} "cd ${r} && ./${m} --version"`;try{const{stdout:i,stderr:t}=await s(a,{cwd:process.cwd()});console.log("PostgreSQL version test stdout:",i),console.log("PostgreSQL version test stderr:",t)}catch(i){console.log("PostgreSQL version test error:",i)}}const p=e?l.spawn("su",["postgres","-c",`cd ${r} && ./${m} ${h.join(" ")}`],{stdio:["pipe","pipe","pipe"]}):l.spawn(`./${m}`,h,{cwd:r});return new Promise((a,i)=>{p.stderr.on("data",async t=>{const d=t?.toString();if(console.log("PostgreSQL stderr:",d),d.includes("database system is ready to accept connections")){const k=(await x(c))?.replace(`
`,""),q=e?`${e} "cd ${r} && ./${u} -h 127.0.0.1 -p ${c} app"`:`./${u} -h 127.0.0.1 -p ${c} app`;s(q,{cwd:e?process.cwd():r}).then(()=>{a(parseInt(k,10))}).catch(({stderr:g})=>{g&&g.includes('database "app" already exists')?a(parseInt(k,10)):console.log(g)})}}),p.stdout.on("data",async t=>{const d=t?.toString();console.log("PostgreSQL stdout:",d)}),p.on("error",t=>{console.log("PostgreSQL process error:",t),i(t)}),p.on("exit",(t,d)=>{console.log(`PostgreSQL process exited with code ${t} and signal ${d}`),t!==0&&i(new Error(`PostgreSQL process exited with code ${t}`))})})}catch(c){console.warn(c),process.exit(1)}};var U=A;export{U as default};
//# sourceMappingURL=index.js.map
