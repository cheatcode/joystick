import _ from"child_process";import L from"fs";import q from"util";import S from"os";import f from"path";import h from"../../../get_platform_safe_path.js";import k from"../../../get_process_id_from_port.js";import b from"../../../path_exists.js";import P from"../../../get_architecture.js";const c=q.promisify(_.exec),{rename:Q}=L.promises,I=async(s=2610)=>{const o=await b(".joystick/data/postgresql");let a=await b(`.joystick/data/postgresql_${s}`);return console.log(`PostgreSQL: legacy_data_directory_exists = ${o}`),console.log(`PostgreSQL: data_directory_exists = ${a}`),console.log(`PostgreSQL: checking paths: .joystick/data/postgresql and .joystick/data/postgresql_${s}`),o&&!a&&(console.log("PostgreSQL: Renaming legacy directory to port-specific directory"),await Q(".joystick/data/postgresql",`.joystick/data/postgresql_${s}`),a=!0),a},D=()=>"createdb",R=()=>"postgres",K=()=>"initdb",z=()=>"pg_ctl",E=async(s=2610)=>{try{const o=s,a=P(),j=f.join(S.homedir(),".joystick","databases","postgresql",a),r=f.join(j,"bin"),d=z(),m=K(),v=R(),u=D(),i=process.platform==="linux"&&process.getuid&&process.getuid()===0,y=await I(s);if(console.log(`PostgreSQL: data_directory_exists = ${y}`),console.log(`PostgreSQL: checking directory ${process.cwd()}/.joystick/data/postgresql_${s}`),!y)if(i){await c(`mkdir -p ${process.cwd()}/.joystick/data/postgresql_${s}`),await c(`chown -R postgres:postgres ${process.cwd()}/.joystick/data`),console.log("PostgreSQL: Running initdb to initialize database cluster...");try{const t=await c(`sudo -u postgres ${r}/${m} -D ${process.cwd()}/.joystick/data/postgresql_${s} --auth-local=trust --auth-host=trust`);console.log("PostgreSQL: initdb completed successfully"),t.stdout&&console.log("initdb stdout:",t.stdout),t.stderr&&console.log("initdb stderr:",t.stderr)}catch(t){throw console.error("PostgreSQL: initdb failed:",t.message),t.stdout&&console.log("initdb stdout:",t.stdout),t.stderr&&console.log("initdb stderr:",t.stderr),t}}else await c(`./${m} -D ${process.cwd()}/.joystick/data/postgresql_${s}`,{cwd:r});const p=parseInt(await k(o),10);p&&(i?await c(`sudo -u postgres ${r}/${d} kill KILL ${p}`):await c(`./${d} kill KILL ${p}`,{cwd:r}));const l=i?_.spawn("sudo",["-u","postgres",`${r}/${d}`,"-o",`"-p ${o}"`,"-D",h(`${process.cwd()}/.joystick/data/postgresql_${s}`),"start"]):_.spawn(`./${d}`,["-o",`"-p ${o}"`,"-D",h(`${process.cwd()}/.joystick/data/postgresql_${s}`),"start"],{cwd:r});return new Promise((t,$)=>{l.stderr.on("data",async e=>{const n=e?.toString();n?.includes("another server might be running")||console.warn(n)}),l.stdout.on("data",async e=>{if((e?.toString()).includes("database system is ready to accept connections")){const w=(await k(o))?.replace(`
`,""),x=i?`sudo -u postgres ${r}/${u} -h 127.0.0.1 -p ${o} app`:`./${u} -h 127.0.0.1 -p ${o} app`;c(x,{cwd:i?process.cwd():r}).then(()=>{t(parseInt(w,10))}).catch(({stderr:g})=>{g&&g.includes('database "app" already exists')?t(parseInt(w,10)):console.log(g)})}}),l.on("error",e=>{console.log("PostgreSQL process error:",e),$(e)}),l.on("exit",(e,n)=>{console.log(`PostgreSQL process exited with code ${e} and signal ${n}`),e!==0&&$(new Error(`PostgreSQL process exited with code ${e}`))})})}catch(o){console.warn(o),process.exit(1)}};var O=E;export{O as default};
//# sourceMappingURL=index.js.map
