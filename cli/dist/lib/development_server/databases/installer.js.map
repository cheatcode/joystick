{
  "version": 3,
  "sources": ["../../../../src/lib/development_server/databases/installer.js"],
  "sourcesContent": ["import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { promisify } from 'util';\nimport { pipeline } from 'stream';\nimport { execFile } from 'child_process';\nimport get_architecture from '../../get_architecture.js';\n\nconst stream_pipeline = promisify(pipeline);\nconst exec_file_async = promisify(execFile);\n\nconst database_versions = {\n  mongodb: '8',\n  postgresql: '17',\n  redis: '7',\n};\n\nconst database_display_names = {\n  mongodb: 'MongoDB',\n  postgresql: 'PostgreSQL',\n  redis: 'Redis',\n};\n\nconst get_platform = () => {\n  const platform = os.platform();\n  if (platform === 'darwin') return 'macos';\n  if (platform === 'linux') return 'linux';\n  throw new Error(`Unsupported platform: ${platform}. Please use WSL2 on Windows.`);\n};\n\n\nconst build_download_url = (database, version, platform, architecture) => {\n  const cache_buster = Date.now();\n  return `https://cdn.joystickjs.com/${database}/${version}/${platform}/${architecture}.tar.gz?t=${cache_buster}`;\n};\n\nconst check_if_file_exists = async (file_path) => {\n  try {\n    await fs.promises.access(file_path);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nconst download_file = async (url, file_path) => {\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`Failed to download ${url}: ${response.statusText}`);\n  }\n  await stream_pipeline(response.body, fs.createWriteStream(file_path));\n};\n\nconst make_files_executable = async (directory, database_name = null) => {\n  try {\n    if (!(await check_if_file_exists(directory))) {\n      return; // Directory doesn't exist, skip\n    }\n\n    const files = await fs.promises.readdir(directory);\n    for (const file of files) {\n      const file_path = path.join(directory, file);\n      const stats = await fs.promises.stat(file_path);\n      if (stats.isFile()) {\n        await fs.promises.chmod(file_path, '755');\n      } else if (stats.isDirectory()) {\n        // Recursively make files executable in subdirectories\n        await make_files_executable(file_path);\n      }\n    }\n  } catch (error) {\n    // Skip errors, but don't warn as this is expected during installation\n  }\n};\n\nconst setup_postgresql_permissions = async (directory) => {\n  if (process.platform !== 'linux' || !process.getuid || process.getuid() !== 0) {\n    return; // Only run on Linux as root\n  }\n\n  const { exec } = await import('child_process');\n  const { promisify } = await import('util');\n  const exec_async = promisify(exec);\n\n  try {\n    // Check if postgres user exists, create if not\n    try {\n      await exec_async('id postgres');\n    } catch (error) {\n      // User doesn't exist, create it with a proper shell\n      await exec_async('useradd -r -s /bin/bash postgres');\n    }\n\n    // Set up directory permissions for postgres user access\n    const homedir = os.homedir();\n    \n    // Ensure all parent directories have execute permissions for postgres user\n    await exec_async(`chmod 755 ${homedir}`);\n    await exec_async(`chmod 755 ${path.join(homedir, '.joystick')}`);\n    await exec_async(`chmod 755 ${path.join(homedir, '.joystick', 'databases')}`);\n    await exec_async(`chmod 755 ${path.join(homedir, '.joystick', 'databases', 'postgresql')}`);\n    await exec_async(`chmod 755 ${directory}`);\n\n    // Change ownership of the entire PostgreSQL installation to postgres user\n    await exec_async(`chown -R postgres:postgres ${directory}`);\n    \n    // Ensure all binaries are executable\n    const bin_directory = path.join(directory, 'bin');\n    if (await check_if_file_exists(bin_directory)) {\n      await exec_async(`chmod -R 755 ${bin_directory}`);\n    }\n  } catch (error) {\n    // If we can't set up postgres user, continue anyway\n    console.warn(`Warning: Could not set up postgres user ownership: ${error.message}`);\n  }\n};\n\nconst install_database = async (database_name) => {\n  const platform = get_platform();\n  const architecture = get_architecture();\n  const base_directory = path.join(os.homedir(), '.joystick', 'databases', database_name);\n  const architecture_directory = path.join(base_directory, architecture);\n\n  // Check if the architecture-specific directory exists\n  if (await check_if_file_exists(architecture_directory)) {\n    return; // Already installed for this architecture\n  }\n\n  const version = database_versions[database_name];\n\n  if (!version) {\n    throw new Error(`Unsupported database: ${database_name}`);\n  }\n\n  const download_url = build_download_url(database_name, version, platform, architecture);\n  const archive_filename = `${database_name}.tar.gz`;\n  const archive_path = path.join(base_directory, archive_filename);\n  const display_name = database_display_names[database_name] || database_name;\n\n  process.loader.print(`${display_name} (${architecture}) not found. Downloading... (this may take a few minutes)`);\n\n  // Create the base directory\n  await fs.promises.mkdir(base_directory, { recursive: true });\n  await download_file(download_url, archive_path);\n\n  process.loader.print(`Installing ${display_name} (${architecture})...`);\n\n  // Extract to base directory first to check structure\n  await exec_file_async('tar', ['-xzf', archive_path, '-C', base_directory]);\n  await fs.promises.unlink(archive_path);\n\n  // Check if tar file already created architecture directory\n  const extracted_arch_dir = path.join(base_directory, architecture);\n  if (await check_if_file_exists(extracted_arch_dir)) {\n    // Tar file already contains architecture directory, we're done\n    await make_files_executable(extracted_arch_dir);\n    if (database_name === 'postgresql') {\n      await setup_postgresql_permissions(extracted_arch_dir);\n    }\n  } else {\n    // Tar file contains flat binaries, move them to architecture directory\n    await fs.promises.mkdir(architecture_directory, { recursive: true });\n    const files = await fs.promises.readdir(base_directory);\n    \n    for (const file of files) {\n      const source_path = path.join(base_directory, file);\n      const dest_path = path.join(architecture_directory, file);\n      \n      // Skip the architecture directory we just created\n      if (file === architecture) continue;\n      \n      await fs.promises.rename(source_path, dest_path);\n    }\n    \n    await make_files_executable(architecture_directory);\n    if (database_name === 'postgresql') {\n      await setup_postgresql_permissions(architecture_directory);\n    }\n  }\n\n  process.loader.print(`${display_name} (${architecture}) installed!`);\n};\n\nexport default install_database;\n"],
  "mappings": "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",
  "names": ["fs", "path", "os", "promisify", "pipeline", "execFile", "get_architecture", "stream_pipeline", "exec_file_async", "database_versions", "database_display_names", "get_platform", "platform", "build_download_url", "database", "version", "architecture", "cache_buster", "check_if_file_exists", "file_path", "download_file", "url", "response", "make_files_executable", "directory", "database_name", "files", "file", "stats", "setup_postgresql_permissions", "exec", "exec_async", "homedir", "bin_directory", "error", "install_database", "base_directory", "architecture_directory", "download_url", "archive_filename", "archive_path", "display_name", "extracted_arch_dir", "source_path", "dest_path", "installer_default"]
}
