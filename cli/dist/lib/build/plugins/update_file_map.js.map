{
  "version": 3,
  "sources": ["../../../../src/lib/build/plugins/update_file_map.js"],
  "sourcesContent": ["import fs from \"fs\";\nimport path, { dirname } from 'path';\nimport * as acorn from \"acorn\";\nimport path_exists from '../../path_exists.js';\n\nconst { readFile, writeFile } = fs.promises;\n\nconst get_requires = (from_path = '', map = {}) => {\n  const requires = map?.body?.filter((statement) => {\n    const type = statement && statement.type;\n    const declarations = (statement && statement.declarations) || [];\n\n    const is_variable_declaration = type === \"VariableDeclaration\";\n\n    const has_require_statement = declarations.some((declaration) => {\n      const is_variable_declarator = declaration.type === \"VariableDeclarator\";\n      const callee_name = declaration?.init?.callee?.name;\n      return is_variable_declarator && callee_name === \"require\";\n    });\n\n    return is_variable_declaration && has_require_statement;\n  });\n\n  return requires.map((require_declaration) => {\n    const declarations = require_declaration.declarations;\n    const declaration = declarations && declarations[0];\n    const declaration_value = declaration?.init?.arguments[0] && declaration.init.arguments[0]?.value;\n\n    return {\n      absolute_path: declaration_value ? path.resolve(dirname(from_path), declaration_value) : null,\n    };\n  });\n};\n\nconst get_imports = (from_path = '', map = {}) => {\n  const imports = map?.body?.filter(({ type }) => {\n    return type === \"ImportDeclaration\";\n  }) || [];\n\n  return imports.map((import_declaration) => {\n    return {\n      path: import_declaration?.source?.value,\n      absolute_path: path.resolve(dirname(from_path), import_declaration?.source?.value),\n    };\n  });\n};\n\nconst get_imports_and_requires = (from_path = '', map = {}) => {\n  const imports = get_imports(from_path, map);\n  const requires = get_requires(from_path, map);\n\n  return {\n    imports,\n    requires,\n  };\n};\n\nconst parse_file_to_ast = (file = \"\") => {\n  return acorn.parse(file, {\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n  });\n};\n\nconst read_file_dependency_map = async () => {\n  const file_dependency_map_path = `.joystick/build/file_map.json`;\n\n  if (await path_exists(file_dependency_map_path)) {\n    const file_dependency_map_as_json = fs.readFileSync(\n      file_dependency_map_path,\n      \"utf-8\"\n    );\n\n    return file_dependency_map_as_json ? JSON.parse(file_dependency_map_as_json) : {};\n  }\n\n  return {};\n};\n\nconst update_file_map = async (from_path = \"\", source = \"\") => {\n  try {\n    const file_dependency_map = await read_file_dependency_map();\n    const file_ast = parse_file_to_ast(source);\n    const imports = file_ast ? get_imports_and_requires(from_path, file_ast) : [];\n\n    file_dependency_map[from_path] = imports;\n\n    fs.writeFileSync(\n      `.joystick/build/file_map.json`,\n      JSON.stringify(file_dependency_map, null, 2)\n    );\n  } catch {\n    // Do nothing. This exists to handle acorn parsing errors that are also picked\n    // up by the esbuild parser (we want to defer to esbuild).\n  }\n};\n\nexport default update_file_map;\n"],
  "mappings": "AAAA,OAAOA,MAAQ,KACf,OAAOC,GAAQ,WAAAC,MAAe,OAC9B,UAAYC,MAAW,QACvB,OAAOC,MAAiB,uBAExB,KAAM,CAAE,SAAAC,EAAU,UAAAC,CAAU,EAAIN,EAAG,SAE7BO,EAAe,CAACC,EAAY,GAAIC,EAAM,CAAC,KAC1BA,GAAK,MAAM,OAAQC,GAAc,CAChD,MAAMC,EAAOD,GAAaA,EAAU,KAC9BE,EAAgBF,GAAaA,EAAU,cAAiB,CAAC,EAEzDG,EAA0BF,IAAS,sBAEnCG,EAAwBF,EAAa,KAAMG,GAAgB,CAC/D,MAAMC,EAAyBD,EAAY,OAAS,qBAC9CE,EAAcF,GAAa,MAAM,QAAQ,KAC/C,OAAOC,GAA0BC,IAAgB,SACnD,CAAC,EAED,OAAOJ,GAA2BC,CACpC,CAAC,GAEe,IAAKI,GAAwB,CAC3C,MAAMN,EAAeM,EAAoB,aACnCH,EAAcH,GAAgBA,EAAa,CAAC,EAC5CO,EAAoBJ,GAAa,MAAM,UAAU,CAAC,GAAKA,EAAY,KAAK,UAAU,CAAC,GAAG,MAE5F,MAAO,CACL,cAAeI,EAAoBlB,EAAK,QAAQC,EAAQM,CAAS,EAAGW,CAAiB,EAAI,IAC3F,CACF,CAAC,EAGGC,EAAc,CAACZ,EAAY,GAAIC,EAAM,CAAC,KAC1BA,GAAK,MAAM,OAAO,CAAC,CAAE,KAAAE,CAAK,IACjCA,IAAS,mBACjB,GAAK,CAAC,GAEQ,IAAKU,IACX,CACL,KAAMA,GAAoB,QAAQ,MAClC,cAAepB,EAAK,QAAQC,EAAQM,CAAS,EAAGa,GAAoB,QAAQ,KAAK,CACnF,EACD,EAGGC,EAA2B,CAACd,EAAY,GAAIC,EAAM,CAAC,IAAM,CAC7D,MAAMc,EAAUH,EAAYZ,EAAWC,CAAG,EACpCe,EAAWjB,EAAaC,EAAWC,CAAG,EAE5C,MAAO,CACL,QAAAc,EACA,SAAAC,CACF,CACF,EAEMC,EAAoB,CAACC,EAAO,KACzBvB,EAAM,MAAMuB,EAAM,CACvB,YAAa,SACb,WAAY,QACd,CAAC,EAGGC,EAA2B,SAAY,CAC3C,MAAMC,EAA2B,gCAEjC,GAAI,MAAMxB,EAAYwB,CAAwB,EAAG,CAC/C,MAAMC,EAA8B7B,EAAG,aACrC4B,EACA,OACF,EAEA,OAAOC,EAA8B,KAAK,MAAMA,CAA2B,EAAI,CAAC,CAClF,CAEA,MAAO,CAAC,CACV,EAEMC,EAAkB,MAAOtB,EAAY,GAAIuB,EAAS,KAAO,CAC7D,GAAI,CACF,MAAMC,EAAsB,MAAML,EAAyB,EACrDM,EAAWR,EAAkBM,CAAM,EACnCR,EAAUU,EAAWX,EAAyBd,EAAWyB,CAAQ,EAAI,CAAC,EAE5ED,EAAoBxB,CAAS,EAAIe,EAEjCvB,EAAG,cACD,gCACA,KAAK,UAAUgC,EAAqB,KAAM,CAAC,CAC7C,CACF,MAAQ,CAGR,CACF,EAEA,IAAOE,EAAQJ",
  "names": ["fs", "path", "dirname", "acorn", "path_exists", "readFile", "writeFile", "get_requires", "from_path", "map", "statement", "type", "declarations", "is_variable_declaration", "has_require_statement", "declaration", "is_variable_declarator", "callee_name", "require_declaration", "declaration_value", "get_imports", "import_declaration", "get_imports_and_requires", "imports", "requires", "parse_file_to_ast", "file", "read_file_dependency_map", "file_dependency_map_path", "file_dependency_map_as_json", "update_file_map", "source", "file_dependency_map", "file_ast", "update_file_map_default"]
}
