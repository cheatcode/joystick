import i from"../../lib/types.js";import m from"./validate_type.js";import"./is_array_path.js";const l=(r,e,t)=>r.includes(e)?{valid:!0,errors:[]}:{valid:!1,errors:[`Field ${t} only allows the following values: ${r.join(", ")}.`]},n=(r,e,t)=>i.is_array(e)&&e?.length<=r?{valid:!0,errors:[]}:{valid:!1,errors:[`Field ${t} length must be less than or equal to ${r}.`]},d=(r,e,t)=>i.is_array(e)&&e?.length>=r?{valid:!0,errors:[]}:{valid:!1,errors:[`Field ${t} length must be greater than or equal to ${r}.`]},v={types:["any","array","boolean","float","integer","number","object","string"],rules:{allowed_values:l,allowedValues:l,element:async(r,e,t,s)=>{if(e&&(i.is_object(r)||i.is_string(r))&&i.is_array(e)){const a=await Promise.all(e.flatMap(async(o,f)=>(await s(o,i.is_string(r)?{type:r}:r,`${t}.${f}`)).flatMap(c=>c)));return{valid:a.length===0,errors:a.flatMap(o=>o)}}return{valid:!0,errors:[]}},fields:async(r,e,t,s)=>{if(i.is_object(r)&&i.is_object(e)){const a=await s(e,r,t);return{valid:a.length===0,errors:[...a]}}return{valid:!1,errors:[`Field ${t} must be of type object.`]}},max:(r,e,t)=>e<=r?{valid:!0,errors:[]}:{valid:!1,errors:[`Field ${t} must be less than or equal to ${r}.`]},max_length:n,maxLength:n,min:(r,e,t)=>e>=r?{valid:!0,errors:[]}:{valid:!1,errors:[`Field ${t} must be greater than or equal to ${r}.`]},min_length:d,minLength:d,optional:(r,e,t)=>(r===!1?!!e:!0)?{valid:!0,errors:[]}:{valid:!1,errors:[`Field ${t} is required.`]},regex:(r,e,t)=>new RegExp(r).test(e)?{valid:!0,errors:[]}:{valid:!1,errors:[`Field ${t} must conform to regex: ${r}.`]},required:(r,e,t)=>(r===!1?!0:!!e)?{valid:!0,errors:[]}:{valid:!1,errors:[`Field ${t} is required.`]},type:(r,e,t)=>{const s=m(r,e);return e&&!s?{valid:!1,errors:[`Field ${t} must be of type ${r}.`]}:{valid:!0,errors:[]}}}};var b=v;export{b as default};
