import d from"./get_value_from_object.js";import y from"./input_validators.js";import b from"./is_array_path.js";import _ from"../../lib/types.js";const j=(t=null,r="",e=!1)=>{if(r&&!_.is_string(r))throw new Error("path must be passed as a string");if(e||!e&&!_.is_object(t))return t;if(r.includes(".$.")){const[o]=r.split(".$.");return d(t,o)}return d(t,r)},w=(t="")=>{if(!t)return"";if(t&&!_.is_string(t))throw new Error("array_path must be a type of string");return t.split(".").pop()},m=({queue:t,rules:r,input:e,path:o,types_only_schema:n})=>{r&&r.type==="object"&&(t=p(t,r.properties,e,o)),r&&r.type==="array"&&_.is_object(r.element)&&(t=p(t,r.element,e,`${o}.$`));const s=b(o)?w(o):o;return{path:o,rules:r,input_value:j(e,s,n)}},p=(t=[],r={},e={},o="")=>{const n=!!(r.type&&y.types.includes(r.type));if(!n){const s=Object.entries(r||{});for(let a=0;a<s?.length;a+=1){const[c,l]=s[a],i=m({queue:t,rules:l,input:e,path:c,types_only_schema:n});t=[...t,i]}}if(n){const s=m({queue:t,rules:r,input:e,path:o,types_only_schema:n});t=[...t,s]}return t},v=async(t={},r={},e="")=>{const o=[],n=p([],r,t,e);return await Promise.all(n.flatMap(s=>Object.entries(s.rules||{}).flatMap(async([a,c])=>{const l=y.rules[a];if(l&&!s.path.includes(".$.")){const i=await l(c,s.input_value,s.path,v);if(i&&!i.valid)for(let f=0;f<i.errors.length;f+=1){const g=i.errors[f];o.push(g)}}}))),o};var E=v;export{E as default,j as handle_get_input_value};
