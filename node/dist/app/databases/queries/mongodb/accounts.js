import a from"../../../../lib/generate_id.js";const n={add_password_reset_token:(e={})=>process.databases._users?.collection("users").updateOne({emailAddress:e.email_address},{$addToSet:{passwordResetTokens:{token:e.token,requestedAt:new Date().toISOString()}}}),add_role:async(e={})=>!(e?.role?await process.databases._users?.collection("roles").findOne({role:e?.role}):null)&&e?.role?(await process.databases._users?.collection("roles").insertOne({_id:a(16),role:e?.role}),{_id:e?.user_id,action:"add",role:e?.role,ok:!0,error:null}):{action:"add",role:e?.role,ok:!1,error:e?.role?`Role already exists: ${e?.role}.`:"Must pass a name for role to add."},add_session:async(e={})=>{await process.databases._users?.collection("users").updateOne({_id:e.user_id},{$addToSet:{sessions:e.session}})},create_email_verification_token:async(e={})=>{const s=a(16);return await process.databases._users?.collection("users").updateOne({_id:e?.user_id},{$addToSet:{verifyEmailTokens:{userId:e?.user_id,token:s}}}),s},create_user:async(e={})=>{const s=a(16);return await process.databases._users?.collection("users").insertOne({_id:s,...e,sessions:[]}),s},delete_old_sessions:async(e={})=>{const s=await process.databases._users?.collection("users").findOne({_id:e?.user_id});if(s){const r=s?.sessions?.filter(o=>new Date(o?.tokenExpiresAt||o?.token_expires_at).toISOString()>new Date().toISOString());await process.databases._users?.collection("users").updateOne({_id:e.user_id},{$set:{sessions:r}})}},delete_user:async(e={})=>process.databases._users?.collection("users").deleteOne({_id:e?.user_id}),existing_user:async(e={})=>{let s,r;return e?.email_address&&(s=await process.databases._users?.collection("users").findOne({emailAddress:e.email_address})),e?.username&&(r=await process.databases._users?.collection("users").findOne({username:e.username})),s||r?{existing_email_address:s?.emailAddress,existing_username:r?.username}:null},get_existing_session:async(e={})=>{const s=await process.databases._users?.collection("users").findOne({_id:e?.user_id});return s?.sessions?.length>0?(s?.sessions.sort((o,t)=>(o.tokenExpiresAt||o.token_expires_at)>(t.tokenExpiresAt||t.token_expires_at)?-1:1)).shift():null},get_password_reset_token:async(e={})=>{const s=await process.databases._users?.collection("users").findOne({_id:e?.user_id});return s&&s?.passwordResetTokens&&s?.passwordResetTokens[0]?.token||null},grant_role:async(e={})=>await process.databases._users?.collection("users").findOne({_id:e?.user_id})?(await process.databases._users?.collection("users").updateOne({_id:e?.user_id},{$addToSet:{roles:e?.role}}),await process.databases._users?.collection("roles").findOne({role:e?.role})||await process.databases._users?.collection("roles").insertOne({_id:a(16),role:e?.role}),{_id:e?.user_id,action:"grant",role:e?.role,ok:!0,error:null}):{_id:e?.user_id,action:"grant",role:e?.role,ok:!1,error:`User not found with the _id ${e?.user_id}.`},list_roles:async()=>(await process.databases._users?.collection("roles").find().toArray()||[]).map(({role:s})=>s),mark_email_verified_at:async(e={})=>{const s=await process.databases._users?.collection("users").findOne({_id:e?.user_id});return await process.databases._users?.collection("users").updateOne({_id:e?.user_id},{$set:{emailVerified:!0,emailVerifiedAt:new Date().toISOString(),verifyEmailTokens:s?.verifyEmailTokens?.filter(r=>r?.token===e?.token)}}),!0},remove_reset_token:async(e={})=>{const s=await process.databases._users?.collection("users").findOne({_id:e?.user_id});return await process.databases._users?.collection("users").updateOne({_id:e?.user_id},{$set:{passwordResetTokens:s?.passwordResetTokens?.filter(({token:r})=>r!==e?.token)}}),process.databases._users?.collection("users").findOne({_id:e?.user_id})},remove_role:async(e={})=>(e?.role?await process.databases._users?.collection("roles").findOne({role:e?.role}):null)?(await process.databases._users?.collection("users").updateMany({roles:{$in:[e?.role]}},{$pull:{roles:e?.role}}),await process.databases._users?.collection("roles").deleteOne({role:e?.role}),{_id:e?.user_id,action:"remove",role:e?.role,ok:!0,error:null}):{action:"add",role:e?.role,ok:!1,error:`Could not find an existing role with the name ${e?.role}.`},reset_user_sessions:async(e={})=>{await process.databases._users?.collection("users").findOne({_id:e?.user_id})&&await process.databases._users?.collection("users").updateOne({_id:e.user_id},{$set:{sessions:[]}})},revoke_role:async(e={})=>{const s=await process.databases._users?.collection("users").findOne({_id:e?.user_id});return s&&s.roles?(await process.databases._users?.collection("users").updateOne({_id:e?.user_id},{$pull:{roles:e?.role}}),{_id:e?.user_id,action:"revoke",role:e?.role,ok:!0,error:null}):{_id:e?.user_id,action:"revoke",role:e?.role,ok:!1,error:`User not found with the _id ${e?.user_id}.`}},set_new_password:async(e={})=>process.databases._users?.collection("users").updateOne({_id:e?.user_id},{$set:{password:e?.hashed_password}}),user:async(e={})=>e?.email_address?await process.databases._users?.collection("users").findOne({emailAddress:e.email_address}):e?.username?await process.databases._users?.collection("users").findOne({username:e.username}):e?._id?await process.databases._users?.collection("users").findOne({_id:e._id}):null,user_has_role:async(e={})=>{const s=await process.databases._users?.collection("users").findOne({_id:e?.user_id});return s&&s.roles?s?.roles?.includes(e?.role):!1},user_with_login_token:async(e={})=>await process.databases._users?.collection("users").findOne({"sessions.token":e?.token}),user_with_reset_token:async(e={})=>await process.databases._users?.collection("users").findOne({"passwordResetTokens.token":e["passwordResetTokens.token"]}),user_with_verify_email_token:async(e={})=>await process.databases._users?.collection("users").findOne({"verifyEmailTokens.token":e?.token})};var l=n;export{l as default};
