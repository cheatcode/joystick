import o from"cluster";import i from"../../../../lib/timestamps.js";const s={add_job:function(e={}){return(this.db?.collection(`queue_${this.queue.name}`)).insertOne({...e,created_by:this.machine_id,attempts:0})},count_jobs:function(e=""){return(this.db?.collection(`queue_${this.queue.name}`)).countDocuments({status:e,locked_by:this.machine_id})},delete_job:function(e=""){return(this.db?.collection(`queue_${this.queue.name}`)).deleteOne({_id:e})},delete_incomplete_jobs_for_machine:function(){return(this.db?.collection(`queue_${this.queue.name}`)).deleteMany({status:{$in:["incomplete","running"]},locked_by:this.machine_id})},get_jobs:function(e={}){return(this.db?.collection(`queue_${this.queue.name}`)).find({...e,environment:process.env.NODE_ENV}).toArray()},get_next_job_to_run:async function(){const e=this.db?.collection(`queue_${this.queue.name}`),t={status:"pending",environment:process.env.NODE_ENV,next_run_at:{$lte:i.get_current_time()},locked_by:{$exists:!1}},n={status:"pending",environment:process.env.NODE_ENV,next_run_at:{$lte:i.get_current_time()},locked_by:null};return this?.queue?.options?.share_jobs_with_other_machines||(t.created_by=this.machine_id,n.created_by=this.machine_id),await e.findOneAndUpdate({$or:[t,n]},{$set:{status:"running",started_at:i.get_current_time(),locked_by:this.machine_id}},{sort:{next_run_at:1}})},initialize_database:async function(){if(o.isPrimary||o.isWorker&&o.worker.id===1){try{await this.db.createCollection(`queue_${this.queue.name}`)}catch{return Promise.resolve()}const e=this.db?.collection(`queue_${this.queue.name}`),t=await e?.indexes();await e.createIndex({status:1}),await e.createIndex({status:1,next_run_at:1}),await e.createIndex({status:1,environment:1,next_run_at:1,locked_by:1}),await e.createIndex({status:1,environment:1,next_run_at:1,locked_by:1,created_at:1}),(this.queue.options?.cleanup?.completedAfterSeconds||this.queue.options?.cleanup?.completed_after_seconds)&&(t?.find(n=>n?.name==="completed_at_1")&&await e.dropIndex({completed_at:1}),await e.createIndex({completed_at:1},{expireAfterSeconds:this?.queue?.options?.cleanup?.completedAfterSeconds||this.queue.options?.cleanup?.completed_after_seconds})),(this.queue.options?.cleanup?.failedAfterSeconds||this.queue.options?.cleanup?.failed_after_seconds)&&(t?.find(n=>n?.name==="failed_at_1")&&await e.dropIndex({failed_at:1}),await e.createIndex({failed_at:1},{expireAfterSeconds:this?.queue?.options?.cleanup?.failedAfterSeconds||this.queue.options?.cleanup?.failed_after_seconds}))}},log_attempt:function(e=""){return(this.db?.collection(`queue_${this.queue.name}`)).updateOne({_id:e},{$inc:{attempts:1}})},requeue_job:function(e="",t=null){return(this.db?.collection(`queue_${this.queue.name}`)).updateOne({_id:e},{$set:{status:"pending",next_run_at:t},$unset:{locked_by:""}})},set_job_completed:function(e=""){return(this.db?.collection(`queue_${this.queue.name}`)).updateOne({_id:e},{$set:{status:"completed",completed_at:i.get_current_time({mongodb_ttl:!0})}})},set_job_failed:function(e="",t=""){return(this.db?.collection(`queue_${this.queue.name}`)).updateOne({_id:e},{$set:{status:"failed",failed_at:i.get_current_time({mongodb_ttl:!0}),error:t}})},set_jobs_for_machine_pending:function(){return(this.db?.collection(`queue_${this.queue.name}`)).updateMany({status:{$in:["pending","running"]},locked_by:this.machine_id},{$set:{status:"pending"},$unset:{locked_by:""}})}};var d=s;export{d as default};
