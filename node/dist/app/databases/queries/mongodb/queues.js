import r from"cluster";import u from"../../../../lib/timestamps.js";const b={add_job:function(e={}){return(this.db?.collection(`queue_${this.queue.name}`)).insertOne({...e,attempts:0})},count_jobs:function(e=""){return(this.db?.collection(`queue_${this.queue.name}`)).countDocuments({status:e,locked_by:this.machine_id})},delete_job:function(e=""){return(this.db?.collection(`queue_${this.queue.name}`)).deleteOne({_id:e})},delete_incomplete_jobs_for_machine:function(){return(this.db?.collection(`queue_${this.queue.name}`)).deleteMany({status:{$in:["incomplete","running"]},locked_by:this.machine_id})},get_jobs:function(e={}){return(this.db?.collection(`queue_${this.queue.name}`)).find({...e,environment:process.env.NODE_ENV}).toArray()},get_next_job_to_run:async function(){const t=await(this.db?.collection(`queue_${this.queue.name}`)).findOneAndUpdate({$or:[{status:"pending",environment:process.env.NODE_ENV,next_run_at:{$lte:u.get_current_time()},locked_by:{$exists:!1}},{status:"pending",environment:process.env.NODE_ENV,next_run_at:{$lte:u.get_current_time()},locked_by:null}]},{$set:{status:"running",started_at:u.get_current_time(),locked_by:this.machine_id}},{sort:{next_run_at:1}});return console.log({next_job:t}),t},initialize_database:async function(){if(r.isPrimary||r.isWorker&&r.worker.id===1){const e=`queue_${this.queue.name}`;(await this.db.listCollections().toArray()).some(n=>n.name===e)||await this.db.createCollection(e);const s=this.db.collection(e),_=await s.indexes(),o=async(n,i={})=>{const c=Object.keys(n).join("_");_.some(l=>l.name===c)||await s.createIndex(n,i)};await o({status:1}),await o({status:1,next_run_at:1}),await o({status:1,environment:1,next_run_at:1,locked_by:1});const a=this.queue.options?.cleanup?.completedAfterSeconds||this.queue.options?.cleanup?.completed_after_seconds;if(a){const n="completed_at_1",i=_.find(c=>c.name===n);i&&i.expireAfterSeconds!==a?(await s.dropIndex(n),await o({completed_at:1},{expireAfterSeconds:a})):i||await o({completed_at:1},{expireAfterSeconds:a})}const d=this.queue.options?.cleanup?.failedAfterSeconds||this.queue.options?.cleanup?.failed_after_seconds;if(d){const n="failed_at_1",i=_.find(c=>c.name===n);i&&i.expireAfterSeconds!==d?(await s.dropIndex(n),await o({failed_at:1},{expireAfterSeconds:d})):i||await o({failed_at:1},{expireAfterSeconds:d})}}},log_attempt:function(e=""){return(this.db?.collection(`queue_${this.queue.name}`)).updateOne({_id:e},{$inc:{attempts:1}})},requeue_job:function(e="",t=null){return(this.db?.collection(`queue_${this.queue.name}`)).updateOne({_id:e},{$set:{status:"pending",next_run_at:t},$unset:{locked_by:""}})},set_job_completed:function(e=""){return(this.db?.collection(`queue_${this.queue.name}`)).updateOne({_id:e},{$set:{status:"completed",completed_at:u.get_current_time({mongodb_ttl:!0})}})},set_job_failed:function(e="",t=""){return(this.db?.collection(`queue_${this.queue.name}`)).updateOne({_id:e},{$set:{status:"failed",failed_at:u.get_current_time({mongodb_ttl:!0}),error:t}})},set_jobs_for_machine_pending:function(){return(this.db?.collection(`queue_${this.queue.name}`)).updateMany({status:{$in:["pending","running"]},locked_by:this.machine_id},{$set:{status:"pending"},$unset:{locked_by:""}})}};var p=b;export{p as default};
