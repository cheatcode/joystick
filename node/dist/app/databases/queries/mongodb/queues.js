import r from"cluster";import c from"../../../../lib/timestamps.js";const f={add_job:function(e={}){const n=this.db?.collection(`queue_${this.queue.name}`),i=e.next_run_at instanceof Date?e.next_run_at:new Date(e.next_run_at);return n.insertOne({...e,next_run_at:i,attempts:0})},count_jobs:function(e=""){return(this.db?.collection(`queue_${this.queue.name}`)).countDocuments({status:e,locked_by:this.machine_id})},delete_job:function(e=""){return(this.db?.collection(`queue_${this.queue.name}`)).deleteOne({_id:e})},delete_incomplete_jobs_for_machine:function(){return(this.db?.collection(`queue_${this.queue.name}`)).deleteMany({status:{$in:["incomplete","running"]},locked_by:this.machine_id})},get_jobs:function(e={}){return(this.db?.collection(`queue_${this.queue.name}`)).find({...e,environment:process.env.NODE_ENV}).toArray()},get_next_job_to_run:async function(){const e=this.db?.collection(`queue_${this.queue.name}`),n=c.get_database_format(this.db),i=c.get_current_time({format:n}),t=await e.findOneAndUpdate({$or:[{status:"pending",environment:process.env.NODE_ENV,$or:[{next_run_at:{$lte:i}},{next_run_at:{$lte:i.toISOString()}}],locked_by:{$exists:!1}},{status:"pending",environment:process.env.NODE_ENV,$or:[{next_run_at:{$lte:i}},{next_run_at:{$lte:i.toISOString()}}],locked_by:null}]},{$set:{status:"running",started_at:c.get_current_time({format:"mongodb"}),locked_by:this.machine_id}},{sort:{next_run_at:1}});return t&&(t.next_run_at&&typeof t.next_run_at=="string"&&(t.next_run_at=new Date(t.next_run_at)),t.started_at&&typeof t.started_at=="string"&&(t.started_at=new Date(t.started_at)),t.completed_at&&typeof t.completed_at=="string"&&(t.completed_at=new Date(t.completed_at)),t.failed_at&&typeof t.failed_at=="string"&&(t.failed_at=new Date(t.failed_at))),t},initialize_database:async function(){if(r.isPrimary||r.isWorker&&r.worker.id===1){const e=`queue_${this.queue.name}`;(await this.db.listCollections().toArray()).some(a=>a.name===e)||await this.db.createCollection(e);const i=this.db.collection(e),t=await i.indexes(),o=async(a,s={})=>{const _=Object.keys(a).join("_");t.some(l=>l.name===_)||await i.createIndex(a,s)};await o({status:1}),await o({status:1,next_run_at:1}),await o({status:1,environment:1,next_run_at:1,locked_by:1});const u=this.queue.options?.cleanup?.completedAfterSeconds||this.queue.options?.cleanup?.completed_after_seconds;if(u){const a="completed_at_1",s=t.find(_=>_.name===a);s&&s.expireAfterSeconds!==u?(await i.dropIndex(a),await o({completed_at:1},{expireAfterSeconds:u})):s||await o({completed_at:1},{expireAfterSeconds:u})}const d=this.queue.options?.cleanup?.failedAfterSeconds||this.queue.options?.cleanup?.failed_after_seconds;if(d){const a="failed_at_1",s=t.find(_=>_.name===a);s&&s.expireAfterSeconds!==d?(await i.dropIndex(a),await o({failed_at:1},{expireAfterSeconds:d})):s||await o({failed_at:1},{expireAfterSeconds:d})}}},log_attempt:function(e=""){return(this.db?.collection(`queue_${this.queue.name}`)).updateOne({_id:e},{$inc:{attempts:1}})},requeue_job:function(e="",n=null){return(this.db?.collection(`queue_${this.queue.name}`)).updateOne({_id:e},{$set:{status:"pending",next_run_at:n},$unset:{locked_by:""}})},set_job_completed:function(e=""){return(this.db?.collection(`queue_${this.queue.name}`)).updateOne({_id:e},{$set:{status:"completed",completed_at:c.get_current_time({format:c.get_database_format(this.db)})}})},set_job_failed:function(e="",n=""){return(this.db?.collection(`queue_${this.queue.name}`)).updateOne({_id:e},{$set:{status:"failed",failed_at:c.get_current_time({format:c.get_database_format(this.db)}),error:n}})},set_jobs_for_machine_pending:function(){return(this.db?.collection(`queue_${this.queue.name}`)).updateMany({status:{$in:["pending","running"]},locked_by:this.machine_id},{$set:{status:"pending"},$unset:{locked_by:""}})}};var p=f;export{p as default};
