import m from"cluster";import _ from"../../../../lib/timestamps.js";const l={add_job:async function(e={}){const t=`queue_${this.queue.name}`,n=`job:${e._id}`,s=`${t}:scheduled`,o={...e,attempts:0,next_run_at:e.next_run_at instanceof Date?e.next_run_at.toISOString():e.next_run_at};await this.db.hset(n,o);const i=new Date(o.next_run_at).getTime();return await this.db.zadd(s,[{score:i,value:e._id}]),{insertedId:e._id}},count_jobs:async function(e=""){const t=`queue_${this.queue.name}`;if(e==="running"){const o=`${t}:locked:${this.machine_id}`;return(await this.db.smembers(o)).length}if(e==="pending"){const o=`${t}:scheduled`;return(await this.db.zrange(o,0,-1)).length}const n=`${t}:${e}`;return(await this.db.smembers(n)).length},delete_job:async function(e=""){const t=`queue_${this.queue.name}`,n=`job:${e}`,s=this.db.multi();return s.del(n),s.zrem(`${t}:scheduled`,e),s.srem(`${t}:pending`,e),s.srem(`${t}:running`,e),s.srem(`${t}:completed`,e),s.srem(`${t}:failed`,e),s.srem(`${t}:locked:${this.machine_id}`,e),await s.exec()},delete_incomplete_jobs_for_machine:async function(){const e=`queue_${this.queue.name}`,t=`${e}:locked:${this.machine_id}`,n=await this.db.smembers(t);if(n.length>0){const s=this.db.multi();for(const o of n)s.del(`job:${o}`),s.srem(`${e}:running`,o);return s.del(t),await s.exec()}return[]},get_jobs:async function(e={}){const t=`queue_${this.queue.name}`;let n=[];if(e.status)if(e.status==="pending")n=await this.db.zrange(`${t}:scheduled`,0,-1);else{const o=`${t}:${e.status}`;n=await this.db.smembers(o)}else{const o=["running","completed","failed"];for(const c of o){const u=await this.db.smembers(`${t}:${c}`);n.push(...u)}const i=await this.db.zrange(`${t}:scheduled`,0,-1);n.push(...i)}const s=[];for(const o of n){const i=await this.db.hgetall(`job:${o}`);Object.keys(i).length>0&&i.environment===process.env.NODE_ENV&&s.push({...i,attempts:parseInt(i.attempts,10)})}return s},get_next_job_to_run:async function(){const e=`queue_${this.queue.name}`,t=`${e}:scheduled`,n=`${e}:pending`,s=`${e}:running`,o=`${e}:locked:${this.machine_id}`,i=Date.now(),c=await this.db.zrangebyscore(t,0,i,{LIMIT:{offset:0,count:1}});if(c.length===0)return null;const u=c[0],a=`job:${u}`,r=await this.db.hgetall(a);if(!r||Object.keys(r).length===0)return await this.db.zrem(t,u),null;if(r.environment!==process.env.NODE_ENV)return null;const d=this.db.multi();d.zrem(t,u),d.srem(n,u),d.sadd(s,u),d.sadd(o,u),d.hset(a,{status:"running",started_at:_.get_current_time({format:"redis"}),locked_by:this.machine_id});const h=await d.exec();return{...r,_id:u,status:"running",started_at:_.get_current_time({format:"redis"}),locked_by:this.machine_id,attempts:parseInt(r.attempts,10)}},initialize_database:async function(){if(m.isPrimary||m.isWorker&&m.worker.id===1){const e=`queue_${this.queue.name}`,t=this.queue.options?.cleanup?.completedAfterSeconds||this.queue.options?.cleanup?.completed_after_seconds}},log_attempt:async function(e=""){const t=`job:${e}`,n=await this.db.hget(t,"attempts")||"0";return await this.db.hset(t,"attempts",(parseInt(n,10)+1).toString())},requeue_job:async function(e="",t=null){const n=`queue_${this.queue.name}`,s=`job:${e}`,o=`${n}:scheduled`,i=`${n}:running`,c=`${n}:locked:${this.machine_id}`,u=t?new Date(t).getTime():Date.now(),a=this.db.multi();return a.srem(i,e),a.srem(c,e),a.zadd(o,[{score:u,value:e}]),a.hset(s,{status:"pending",next_run_at:t?new Date(t).toISOString():new Date().toISOString()}),a.hdel(s,"locked_by"),await a.exec()},set_job_completed:async function(e=""){const t=`queue_${this.queue.name}`,n=`job:${e}`,s=`${t}:running`,o=`${t}:completed`,i=`${t}:locked:${this.machine_id}`,c=this.db.multi();return c.srem(s,e),c.srem(i,e),c.sadd(o,e),c.hset(n,{status:"completed",completed_at:_.get_current_time({format:"redis"})}),await c.exec()},set_job_failed:async function(e="",t=""){const n=`queue_${this.queue.name}`,s=`job:${e}`,o=`${n}:running`,i=`${n}:failed`,c=`${n}:locked:${this.machine_id}`,u=this.db.multi();return u.srem(o,e),u.srem(c,e),u.sadd(i,e),u.hset(s,{status:"failed",failed_at:_.get_current_time({format:"redis"}),error:t.toString()}),await u.exec()},set_jobs_for_machine_pending:async function(){const e=`queue_${this.queue.name}`,t=`${e}:locked:${this.machine_id}`,n=`${e}:running`,s=`${e}:scheduled`,o=await this.db.smembers(t);if(o.length>0){const i=this.db.multi();for(const c of o){const u=`job:${c}`,a=await this.db.hget(u,"next_run_at"),r=a?new Date(a).getTime():Date.now();i.srem(n,c),i.zadd(s,[{score:r,value:c}]),i.hset(u,{status:"pending"}),i.hdel(u,"locked_by")}return i.del(t),await i.exec()}return[]}};var k=l;export{k as default};
