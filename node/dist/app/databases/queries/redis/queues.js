import m from"cluster";import l from"../../../../lib/timestamps.js";const b={add_job:async function(e={}){const t=`queue_${this.queue.name}`,n=`job:${e._id}`,o=`${t}:scheduled`,s={...e,attempts:0,next_run_at:e.next_run_at instanceof Date?e.next_run_at.toISOString():e.next_run_at},i={};for(const[c,u]of Object.entries(s))typeof u=="object"&&u!==null?i[c]=JSON.stringify(u):i[c]=String(u);await this.db.hset(n,i);const a=new Date(s.next_run_at).getTime();return await this.db.zadd(o,{score:a,value:e._id}),{insertedId:e._id}},count_jobs:async function(e=""){const t=`queue_${this.queue.name}`;if(e==="running"){const s=`${t}:locked:${this.machine_id}`;return(await this.db.smembers(s)).length}if(e==="pending"){const s=`${t}:scheduled`;return(await this.db.zrange(s,0,-1)).length}const n=`${t}:${e}`;return(await this.db.smembers(n)).length},delete_job:async function(e=""){const t=`queue_${this.queue.name}`,n=`job:${e}`;return await this.db.client.multi().del(n).zRem(`${t}:scheduled`,e).sRem(`${t}:pending`,e).sRem(`${t}:running`,e).sRem(`${t}:completed`,e).sRem(`${t}:failed`,e).sRem(`${t}:locked:${this.machine_id}`,e).exec()},delete_incomplete_jobs_for_machine:async function(){const e=`queue_${this.queue.name}`,t=`${e}:locked:${this.machine_id}`,n=await this.db.smembers(t);if(n.length>0){let o=this.db.client.multi();for(const s of n)o=o.del(`job:${s}`).sRem(`${e}:running`,s);return await o.del(t).exec()}return[]},get_jobs:async function(e={}){const t=`queue_${this.queue.name}`;let n=[];if(e.status)if(e.status==="pending")n=await this.db.zrange(`${t}:scheduled`,0,-1);else{const s=`${t}:${e.status}`;n=await this.db.smembers(s)}else{const s=["running","completed","failed"];for(const a of s){const c=await this.db.smembers(`${t}:${a}`);n.push(...c)}const i=await this.db.zrange(`${t}:scheduled`,0,-1);n.push(...i)}const o=[];for(const s of n){const i=await this.db.hgetall(`job:${s}`);if(Object.keys(i).length>0&&i.environment===process.env.NODE_ENV){const a={...i};for(const[c,u]of Object.entries(a))if(typeof u=="string"&&(u.startsWith("{")||u.startsWith("[")))try{a[c]=JSON.parse(u)}catch{}o.push({...a,attempts:parseInt(a.attempts,10)})}}return o},get_next_job_to_run:async function(){const e=`queue_${this.queue.name}`,t=`${e}:scheduled`,n=`${e}:pending`,o=`${e}:running`,s=`${e}:locked:${this.machine_id}`,i=Date.now(),a=await this.db.zrangebyscore(t,0,i,{LIMIT:{offset:0,count:1}});if(a.length===0)return null;const c=a[0],u=`job:${c}`,r=await this.db.hgetall(u);if(!r||Object.keys(r).length===0)return await this.db.zrem(t,c),null;if(r.environment!==process.env.NODE_ENV)return null;const f=await this.db.client.multi().zRem(t,c).sRem(n,c).sAdd(o,c).sAdd(s,c).hSet(u,{status:"running",started_at:l.get_current_time({format:"redis"}),locked_by:String(this.machine_id)}).exec(),d={...r};for(const[h,_]of Object.entries(d))if(typeof _=="string"&&(_.startsWith("{")||_.startsWith("[")))try{d[h]=JSON.parse(_)}catch{}return{...d,_id:c,status:"running",started_at:l.get_current_time({format:"redis"}),locked_by:this.machine_id,attempts:parseInt(d.attempts,10)}},initialize_database:async function(){if(m.isPrimary||m.isWorker&&m.worker.id===1){const e=`queue_${this.queue.name}`,t=this.queue.options?.cleanup?.completedAfterSeconds||this.queue.options?.cleanup?.completed_after_seconds}},log_attempt:async function(e=""){const t=`job:${e}`,n=await this.db.hget(t,"attempts")||"0";return await this.db.hset(t,"attempts",(parseInt(n,10)+1).toString())},requeue_job:async function(e="",t=null){const n=`queue_${this.queue.name}`,o=`job:${e}`,s=`${n}:scheduled`,i=`${n}:running`,a=`${n}:locked:${this.machine_id}`,c=t?new Date(t).getTime():Date.now();return await this.db.client.multi().sRem(i,e).sRem(a,e).zAdd(s,{score:c,value:e}).hSet(o,{status:"pending",next_run_at:t?new Date(t).toISOString():new Date().toISOString()}).hDel(o,"locked_by").exec()},set_job_completed:async function(e=""){const t=`queue_${this.queue.name}`,n=`job:${e}`,o=`${t}:running`,s=`${t}:completed`,i=`${t}:locked:${this.machine_id}`;return await this.db.client.multi().sRem(o,e).sRem(i,e).sAdd(s,e).hSet(n,{status:"completed",completed_at:l.get_current_time({format:"redis"})}).exec()},set_job_failed:async function(e="",t=""){const n=`queue_${this.queue.name}`,o=`job:${e}`,s=`${n}:running`,i=`${n}:failed`,a=`${n}:locked:${this.machine_id}`;return await this.db.client.multi().sRem(s,e).sRem(a,e).sAdd(i,e).hSet(o,{status:"failed",failed_at:l.get_current_time({format:"redis"}),error:t.toString()}).exec()},set_jobs_for_machine_pending:async function(){const e=`queue_${this.queue.name}`,t=`${e}:locked:${this.machine_id}`,n=`${e}:running`,o=`${e}:scheduled`,s=await this.db.smembers(t);if(s.length>0){let i=this.db.client.multi();for(const a of s){const c=`job:${a}`,u=await this.db.hget(c,"next_run_at"),r=u?new Date(u).getTime():Date.now();i=i.sRem(n,a).zAdd(o,{score:r,value:a}).hSet(c,{status:"pending"}).hDel(c,"locked_by")}return await i.del(t).exec()}return[]}};var y=b;export{y as default};
