import h from"cluster";import m from"../../../../lib/timestamps.js";const b={add_job:async function(e={}){const t=`queue_${this.queue.name}`,n=`job:${e._id}`,i=`${t}:scheduled`,s={...e,attempts:0,next_run_at:e.next_run_at instanceof Date?e.next_run_at.toISOString():e.next_run_at},o={};for(const[c,u]of Object.entries(s))typeof u=="object"&&u!==null?o[c]=JSON.stringify(u):o[c]=String(u);await this.db.hset(n,o);const a=new Date(s.next_run_at).getTime();return await this.db.zadd(i,{score:a,value:e._id}),{insertedId:e._id}},count_jobs:async function(e=""){const t=`queue_${this.queue.name}`;if(e==="running"){const s=`${t}:locked:${this.machine_id}`;return(await this.db.smembers(s)).length}if(e==="pending"){const s=`${t}:scheduled`;return(await this.db.zrange(s,0,-1)).length}const n=`${t}:${e}`;return(await this.db.smembers(n)).length},delete_job:async function(e=""){const t=`queue_${this.queue.name}`,n=`job:${e}`;return await this.db.client.multi().del(n).zRem(`${t}:scheduled`,e).sRem(`${t}:pending`,e).sRem(`${t}:running`,e).sRem(`${t}:completed`,e).sRem(`${t}:failed`,e).sRem(`${t}:locked:${this.machine_id}`,e).exec()},delete_incomplete_jobs_for_machine:async function(){const e=`queue_${this.queue.name}`,t=`${e}:locked:${this.machine_id}`,n=await this.db.smembers(t);if(n.length>0){let i=this.db.client.multi();for(const s of n)i=i.del(`job:${s}`).sRem(`${e}:running`,s);return await i.del(t).exec()}return[]},get_jobs:async function(e={}){const t=`queue_${this.queue.name}`;let n=[];if(e.status)if(e.status==="pending")n=await this.db.zrange(`${t}:scheduled`,0,-1);else{const s=`${t}:${e.status}`;n=await this.db.smembers(s)}else{const s=["running","completed","failed"];for(const a of s){const c=await this.db.smembers(`${t}:${a}`);n.push(...c)}const o=await this.db.zrange(`${t}:scheduled`,0,-1);n.push(...o)}const i=[];for(const s of n){const o=await this.db.hgetall(`job:${s}`);if(Object.keys(o).length>0&&o.environment===process.env.NODE_ENV){const a={...o};for(const[c,u]of Object.entries(a))if(typeof u=="string"&&(u.startsWith("{")||u.startsWith("[")))try{a[c]=JSON.parse(u)}catch{}i.push({...a,attempts:parseInt(a.attempts,10)})}}return i},get_next_job_to_run:async function(){const e=`queue_${this.queue.name}`,t=`${e}:scheduled`,n=`${e}:pending`,i=`${e}:running`,s=`${e}:locked:${this.machine_id}`,o=Date.now(),a=await this.db.zrangebyscore(t,0,o,{LIMIT:{offset:0,count:1}});if(a.length===0)return null;const c=a[0],u=`job:${c}`,d=await this.db.hgetall(u);if(!d||Object.keys(d).length===0)return await this.db.zrem(t,c),null;if(d.environment!==process.env.NODE_ENV)return null;const r=await this.db.client.multi().zRem(t,c).sRem(n,c).sAdd(i,c).sAdd(s,c).hSet(u,{status:"running",started_at:m.get_current_time({format:"redis"}),locked_by:String(this.machine_id)}).exec(),_={...d};for(const[f,l]of Object.entries(_))if(typeof l=="string"&&(l.startsWith("{")||l.startsWith("[")))try{_[f]=JSON.parse(l)}catch{}return{..._,_id:c,status:"running",started_at:m.get_current_time({format:"redis"}),locked_by:this.machine_id,attempts:parseInt(_.attempts,10)}},initialize_database:async function(){if(h.isPrimary||h.isWorker&&h.worker.id===1){const e=`queue_${this.queue.name}`,t=this.queue.options?.cleanup?.completedAfterSeconds||this.queue.options?.cleanup?.completed_after_seconds,n=this.queue.options?.cleanup?.failedAfterSeconds||this.queue.options?.cleanup?.failed_after_seconds;if(t||n){const i=this.cleanup_expired_jobs.bind(this);setInterval(async()=>{try{await i()}catch(s){console.warn(`Error during queue cleanup for ${e}:`,s)}},5*60*1e3)}}},log_attempt:async function(e=""){const t=`job:${e}`,n=await this.db.hget(t,"attempts")||"0";return await this.db.hset(t,"attempts",(parseInt(n,10)+1).toString())},requeue_job:async function(e="",t=null){const n=`queue_${this.queue.name}`,i=`job:${e}`,s=`${n}:scheduled`,o=`${n}:running`,a=`${n}:locked:${this.machine_id}`,c=t?new Date(t).getTime():Date.now();return await this.db.client.multi().sRem(o,e).sRem(a,e).zAdd(s,{score:c,value:e}).hSet(i,{status:"pending",next_run_at:t?new Date(t).toISOString():new Date().toISOString()}).hDel(i,"locked_by").exec()},set_job_completed:async function(e=""){const t=`queue_${this.queue.name}`,n=`job:${e}`,i=`${t}:running`,s=`${t}:completed`,o=`${t}:locked:${this.machine_id}`;return await this.db.client.multi().sRem(i,e).sRem(o,e).sAdd(s,e).hSet(n,{status:"completed",completed_at:m.get_current_time({format:"redis"})}).exec()},set_job_failed:async function(e="",t=""){const n=`queue_${this.queue.name}`,i=`job:${e}`,s=`${n}:running`,o=`${n}:failed`,a=`${n}:locked:${this.machine_id}`;return await this.db.client.multi().sRem(s,e).sRem(a,e).sAdd(o,e).hSet(i,{status:"failed",failed_at:m.get_current_time({format:"redis"}),error:t.toString()}).exec()},set_jobs_for_machine_pending:async function(){const e=`queue_${this.queue.name}`,t=`${e}:locked:${this.machine_id}`,n=`${e}:running`,i=`${e}:scheduled`,s=await this.db.smembers(t);if(s.length>0){let o=this.db.client.multi();for(const a of s){const c=`job:${a}`,u=await this.db.hget(c,"next_run_at"),d=u?new Date(u).getTime():Date.now();o=o.sRem(n,a).zAdd(i,{score:d,value:a}).hSet(c,{status:"pending"}).hDel(c,"locked_by")}return await o.del(t).exec()}return[]},cleanup_expired_jobs:async function(){const e=`queue_${this.queue.name}`,t=Date.now(),n=this.queue.options?.cleanup?.completedAfterSeconds||this.queue.options?.cleanup?.completed_after_seconds,i=this.queue.options?.cleanup?.failedAfterSeconds||this.queue.options?.cleanup?.failed_after_seconds;let s=0;if(n){const o=`${e}:completed`,a=await this.db.smembers(o),c=t-n*1e3;for(const u of a){const d=`job:${u}`,r=await this.db.hgetall(d);r.completed_at&&new Date(r.completed_at).getTime()<c&&(await this.db.client.multi().sRem(o,u).del(d).exec(),s++)}}if(i){const o=`${e}:failed`,a=await this.db.smembers(o),c=t-i*1e3;for(const u of a){const d=`job:${u}`,r=await this.db.hgetall(d);r.failed_at&&new Date(r.failed_at).getTime()<c&&(await this.db.client.multi().sRem(o,u).del(d).exec(),s++)}}return s>0&&console.log(`Cleaned up ${s} expired jobs from queue ${e}`),s}};var y=b;export{y as default};
