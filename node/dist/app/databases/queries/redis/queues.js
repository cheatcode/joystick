import h from"cluster";import m from"../../../../lib/timestamps.js";const f={add_job:async function(e={}){const t=`queue_${this.queue.name}`,s=`job:${e._id}`,n=`${t}:scheduled`,o={...e,attempts:0,next_run_at:e.next_run_at instanceof Date?e.next_run_at.toISOString():e.next_run_at},i={};for(const[c,u]of Object.entries(o))typeof u=="object"&&u!==null?i[c]=JSON.stringify(u):i[c]=String(u);await this.db.hset(s,i);const a=new Date(o.next_run_at).getTime();return await this.db.zadd(n,{score:a,value:e._id}),{insertedId:e._id}},count_jobs:async function(e=""){const t=`queue_${this.queue.name}`;if(e==="running"){const o=`${t}:locked:${this.machine_id}`;return(await this.db.smembers(o)).length}if(e==="pending"){const o=`${t}:scheduled`;return(await this.db.zrange(o,0,-1)).length}const s=`${t}:${e}`;return(await this.db.smembers(s)).length},delete_job:async function(e=""){const t=`queue_${this.queue.name}`,s=`job:${e}`,n=this.db.multi();return n.del(s),n.zrem(`${t}:scheduled`,e),n.srem(`${t}:pending`,e),n.srem(`${t}:running`,e),n.srem(`${t}:completed`,e),n.srem(`${t}:failed`,e),n.srem(`${t}:locked:${this.machine_id}`,e),await n.exec()},delete_incomplete_jobs_for_machine:async function(){const e=`queue_${this.queue.name}`,t=`${e}:locked:${this.machine_id}`,s=await this.db.smembers(t);if(s.length>0){const n=this.db.multi();for(const o of s)n.del(`job:${o}`),n.srem(`${e}:running`,o);return n.del(t),await n.exec()}return[]},get_jobs:async function(e={}){const t=`queue_${this.queue.name}`;let s=[];if(e.status)if(e.status==="pending")s=await this.db.zrange(`${t}:scheduled`,0,-1);else{const o=`${t}:${e.status}`;s=await this.db.smembers(o)}else{const o=["running","completed","failed"];for(const a of o){const c=await this.db.smembers(`${t}:${a}`);s.push(...c)}const i=await this.db.zrange(`${t}:scheduled`,0,-1);s.push(...i)}const n=[];for(const o of s){const i=await this.db.hgetall(`job:${o}`);if(Object.keys(i).length>0&&i.environment===process.env.NODE_ENV){const a={...i};for(const[c,u]of Object.entries(a))if(typeof u=="string"&&(u.startsWith("{")||u.startsWith("[")))try{a[c]=JSON.parse(u)}catch{}n.push({...a,attempts:parseInt(a.attempts,10)})}}return n},get_next_job_to_run:async function(){console.log("GNJTR",this.db);const e=`queue_${this.queue.name}`,t=`${e}:scheduled`,s=`${e}:pending`,n=`${e}:running`,o=`${e}:locked:${this.machine_id}`,i=Date.now(),a=await this.db.zrangebyscore(t,0,i,{LIMIT:{offset:0,count:1}});if(a.length===0)return null;const c=a[0],u=`job:${c}`,r=await this.db.hgetall(u);if(!r||Object.keys(r).length===0)return await this.db.zrem(t,c),null;if(r.environment!==process.env.NODE_ENV)return null;const d=this.db.multi();console.log("MULTI HAS NO ZREM",d),d.zrem(t,c),d.srem(s,c),d.sadd(n,c),d.sadd(o,c),d.hset(u,{status:"running",started_at:m.get_current_time({format:"redis"}),locked_by:String(this.machine_id)});const $=await d.exec(),_={...r};for(const[b,l]of Object.entries(_))if(typeof l=="string"&&(l.startsWith("{")||l.startsWith("[")))try{_[b]=JSON.parse(l)}catch{}return{..._,_id:c,status:"running",started_at:m.get_current_time({format:"redis"}),locked_by:this.machine_id,attempts:parseInt(_.attempts,10)}},initialize_database:async function(){if(h.isPrimary||h.isWorker&&h.worker.id===1){const e=`queue_${this.queue.name}`,t=this.queue.options?.cleanup?.completedAfterSeconds||this.queue.options?.cleanup?.completed_after_seconds}},log_attempt:async function(e=""){const t=`job:${e}`,s=await this.db.hget(t,"attempts")||"0";return await this.db.hset(t,"attempts",(parseInt(s,10)+1).toString())},requeue_job:async function(e="",t=null){const s=`queue_${this.queue.name}`,n=`job:${e}`,o=`${s}:scheduled`,i=`${s}:running`,a=`${s}:locked:${this.machine_id}`,c=t?new Date(t).getTime():Date.now(),u=this.db.multi();return u.srem(i,e),u.srem(a,e),u.zadd(o,{score:c,value:e}),u.hset(n,{status:"pending",next_run_at:t?new Date(t).toISOString():new Date().toISOString()}),u.hdel(n,"locked_by"),await u.exec()},set_job_completed:async function(e=""){const t=`queue_${this.queue.name}`,s=`job:${e}`,n=`${t}:running`,o=`${t}:completed`,i=`${t}:locked:${this.machine_id}`,a=this.db.multi();return a.srem(n,e),a.srem(i,e),a.sadd(o,e),a.hset(s,{status:"completed",completed_at:m.get_current_time({format:"redis"})}),await a.exec()},set_job_failed:async function(e="",t=""){const s=`queue_${this.queue.name}`,n=`job:${e}`,o=`${s}:running`,i=`${s}:failed`,a=`${s}:locked:${this.machine_id}`,c=this.db.multi();return c.srem(o,e),c.srem(a,e),c.sadd(i,e),c.hset(n,{status:"failed",failed_at:m.get_current_time({format:"redis"}),error:t.toString()}),await c.exec()},set_jobs_for_machine_pending:async function(){const e=`queue_${this.queue.name}`,t=`${e}:locked:${this.machine_id}`,s=`${e}:running`,n=`${e}:scheduled`,o=await this.db.smembers(t);if(o.length>0){const i=this.db.multi();for(const a of o){const c=`job:${a}`,u=await this.db.hget(c,"next_run_at"),r=u?new Date(u).getTime():Date.now();i.srem(s,a),i.zadd(n,{score:r,value:a}),i.hset(c,{status:"pending"}),i.hdel(c,"locked_by")}return i.del(t),await i.exec()}return[]}};var p=f;export{p as default};
