import h from"cluster";import l from"../../../../lib/timestamps.js";const b={add_job:async function(e={}){const t=`queue_${this.queue.name}`,n=`job:${e._id}`,o=`${t}:scheduled`,s=`${t}_jobs`,i={...e,attempts:0,next_run_at:e.next_run_at instanceof Date?e.next_run_at.toISOString():e.next_run_at},c={};for(const[u,d]of Object.entries(i))typeof d=="object"&&d!==null?c[u]=JSON.stringify(d):c[u]=String(d);await this.db.hset(n,c);const a=new Date(i.next_run_at).getTime();return await this.db.zadd(o,{score:a,value:e._id}),await this.db.publish(s,e._id),{insertedId:e._id}},count_jobs:async function(e=""){const t=`queue_${this.queue.name}`;if(e==="running"){const s=`${t}:locked:${this.machine_id}`;return(await this.db.smembers(s)).length}if(e==="pending"){const s=`${t}:scheduled`;return(await this.db.zrange(s,0,-1)).length}const n=`${t}:${e}`;return(await this.db.smembers(n)).length},delete_job:async function(e=""){const t=`queue_${this.queue.name}`,n=`job:${e}`;return await this.db.client.multi().del(n).zRem(`${t}:scheduled`,e).sRem(`${t}:pending`,e).sRem(`${t}:running`,e).sRem(`${t}:completed`,e).sRem(`${t}:failed`,e).sRem(`${t}:locked:${this.machine_id}`,e).exec()},delete_incomplete_jobs_for_machine:async function(){const e=`queue_${this.queue.name}`,t=`${e}:locked:${this.machine_id}`,n=await this.db.smembers(t);if(n.length>0){let o=this.db.client.multi();for(const s of n)o=o.del(`job:${s}`).sRem(`${e}:running`,s);return await o.del(t).exec()}return[]},get_jobs:async function(e={}){const t=`queue_${this.queue.name}`;let n=[];if(e.status)if(e.status==="pending")n=await this.db.zrange(`${t}:scheduled`,0,-1);else{const s=`${t}:${e.status}`;n=await this.db.smembers(s)}else{const s=["running","completed","failed"];for(const c of s){const a=await this.db.smembers(`${t}:${c}`);n.push(...a)}const i=await this.db.zrange(`${t}:scheduled`,0,-1);n.push(...i)}const o=[];for(const s of n){const i=await this.db.hgetall(`job:${s}`);if(Object.keys(i).length>0&&i.environment===process.env.NODE_ENV){const c={...i};for(const[a,u]of Object.entries(c))if(typeof u=="string"&&(u.startsWith("{")||u.startsWith("[")))try{c[a]=JSON.parse(u)}catch{}o.push({...c,attempts:parseInt(c.attempts,10)})}}return o},get_next_job_to_run:async function(){const e=`queue_${this.queue.name}`,t=`${e}:scheduled`,n=`${e}:pending`,o=`${e}:running`,s=`${e}:locked:${this.machine_id}`,i=Date.now(),c=await this.db.zrangebyscore(t,0,i,{LIMIT:{offset:0,count:1}});if(c.length===0)return null;const a=c[0],u=`job:${a}`,d=await this.db.hgetall(u);if(!d||Object.keys(d).length===0)return await this.db.zrem(t,a),null;if(d.environment!==process.env.NODE_ENV)return null;await this.db.client.multi().zRem(t,a).sRem(n,a).sAdd(o,a).sAdd(s,a).hSet(u,{status:"running",started_at:l.get_current_time({format:"redis"}),locked_by:String(this.machine_id)}).exec();const r={...d};for(const[m,_]of Object.entries(r))if(typeof _=="string"&&(_.startsWith("{")||_.startsWith("[")))try{r[m]=JSON.parse(_)}catch{}return{...r,_id:a,status:"running",started_at:l.get_current_time({format:"redis"}),locked_by:this.machine_id,attempts:parseInt(r.attempts,10)}},initialize_database:async function(){if(h.isPrimary||h.isWorker&&h.worker.id===1){const e=`queue_${this.queue.name}`,t=this.queue.options?.cleanup?.completedAfterSeconds||this.queue.options?.cleanup?.completed_after_seconds,n=this.queue.options?.cleanup?.failedAfterSeconds||this.queue.options?.cleanup?.failed_after_seconds;(t||n)&&setInterval(async()=>{try{const o=Date.now();let s=0;if(t){const i=`${e}:completed`,c=await this.db.smembers(i),a=o-t*1e3;for(const u of c){const d=`job:${u}`,r=await this.db.hgetall(d);r.completed_at&&new Date(r.completed_at).getTime()<a&&(await this.db.client.multi().sRem(i,u).del(d).exec(),s++)}}if(n){const i=`${e}:failed`,c=await this.db.smembers(i),a=o-n*1e3;for(const u of c){const d=`job:${u}`,r=await this.db.hgetall(d);r.failed_at&&new Date(r.failed_at).getTime()<a&&(await this.db.client.multi().sRem(i,u).del(d).exec(),s++)}}}catch(o){console.warn(`Error during queue cleanup for ${e}:`,o)}},30*1e3)}},log_attempt:async function(e=""){const t=`job:${e}`,n=await this.db.hget(t,"attempts")||"0";return await this.db.hset(t,"attempts",(parseInt(n,10)+1).toString())},requeue_job:async function(e="",t=null){const n=`queue_${this.queue.name}`,o=`job:${e}`,s=`${n}:scheduled`,i=`${n}:running`,c=`${n}:locked:${this.machine_id}`,a=t?new Date(t).getTime():Date.now();return await this.db.client.multi().sRem(i,e).sRem(c,e).zAdd(s,{score:a,value:e}).hSet(o,{status:"pending",next_run_at:t?new Date(t).toISOString():new Date().toISOString()}).hDel(o,"locked_by").exec()},set_job_completed:async function(e=""){const t=`queue_${this.queue.name}`,n=`job:${e}`,o=`${t}:running`,s=`${t}:completed`,i=`${t}:locked:${this.machine_id}`;return await this.db.client.multi().sRem(o,e).sRem(i,e).sAdd(s,e).hSet(n,{status:"completed",completed_at:l.get_current_time({format:"redis"})}).exec()},set_job_failed:async function(e="",t=""){const n=`queue_${this.queue.name}`,o=`job:${e}`,s=`${n}:running`,i=`${n}:failed`,c=`${n}:locked:${this.machine_id}`;return await this.db.client.multi().sRem(s,e).sRem(c,e).sAdd(i,e).hSet(o,{status:"failed",failed_at:l.get_current_time({format:"redis"}),error:t.toString()}).exec()},set_jobs_for_machine_pending:async function(){const e=`queue_${this.queue.name}`,t=`${e}:locked:${this.machine_id}`,n=`${e}:running`,o=`${e}:scheduled`,s=await this.db.smembers(t);if(s.length>0){let i=this.db.client.multi();for(const c of s){const a=`job:${c}`,u=await this.db.hget(a,"next_run_at"),d=u?new Date(u).getTime():Date.now();i=i.sRem(n,c).zAdd(o,{score:d,value:c}).hSet(a,{status:"pending"}).hDel(a,"locked_by")}return await i.del(t).exec()}return[]}};var g=b;export{g as default};
