import v from"../app/databases/get_target_database_connection.js";import O from"../lib/generate_id.js";const y=(c="",t={})=>{const u={ttl:null,max_items:null,...t},$=v("cache");return $?.provider==="redis"?b(c,$.connection,u):k(c,u)},k=(c,t={})=>{const{ttl:u,max_items:$}=t,p=e=>{const d=Date.now();return{...e,_cache_created_at:d,_cache_accessed_at:d}},s=()=>{if(!u||!process.caches[c])return;const e=Date.now(),d=u*1e3;process.caches[c]=process.caches[c].filter(a=>e-a._cache_created_at<d)},m=()=>{!$||!process.caches[c]||process.caches[c].length>$&&(process.caches[c].sort((e,d)=>d._cache_accessed_at-e._cache_accessed_at),process.caches[c]=process.caches[c].slice(0,$))},g=e=>(e._cache_accessed_at=Date.now(),e);return{add:(e={})=>{s();const d=p(e);process.caches[c]=[...process.caches[c]||[],d],m()},find:(e=null)=>(s(),(e?process.caches[c]?.filter(a=>a[e[0]]===e[1]):process.caches[c])?.map(g)||[]),find_one:(e=null)=>{s();const d=e?process.caches[c]?.find(a=>a[e[0]]===e[1]):null;return d?g(d):null},set:(e=[])=>{const d=e.map(p);process.caches[c]=d,m()},update:([e="",d=""],a={})=>{s();const r=process.caches[c]?.findIndex((i={})=>i[e]===d);typeof r=="number"&&(process.caches[c][r]={...process.caches[c][r]||{},...a,_cache_accessed_at:Date.now()})},remove:([e="",d=""])=>{process.caches[c]&&(process.caches[c]=process.caches[c].filter((a={})=>a[e]!==d))}}},b=(c,t,u={})=>{const{ttl:$,max_items:p}=u,s=`cache:${c}`,m=`${s}:lru`,g=async()=>{if(!p)return;const a=await t.scard(`${s}:index`);if(a>p){const r=a-p,i=await t.zrange(m,0,r-1);for(const o of i)await d(o)}},e=async a=>{p&&await t.zadd(m,{score:Date.now(),value:a})},d=async a=>{const r=`${s}:${a}`,i=await t.hget(r,"data");if(i){const o=JSON.parse(i);for(const[f,l]of Object.entries(o))f!=="_cache_id"&&(await t.srem(`${s}:field:${f}:${l}`,a),await t.scard(`${s}:field:${f}:${l}`)===0&&await t.del(`${s}:field:${f}:${l}`))}await t.del(r),await t.srem(`${s}:index`,a),await t.zrem(m,a)};return{add:async(a={})=>{a._cache_id||(a._cache_id=O(16));const r=`${s}:${a._cache_id}`;await t.hset(r,"data",JSON.stringify(a)),await t.sadd(`${s}:index`,a._cache_id),await e(a._cache_id);for(const[i,o]of Object.entries(a))i!=="_cache_id"&&await t.sadd(`${s}:field:${i}:${o}`,a._cache_id);$&&await t.expire(r,$),await g()},find:async(a=null)=>{if(!a){const l=await t.smembers(`${s}:index`),w=[];for(const h of l){const _=await t.hget(`${s}:${h}`,"data");_?(w.push(JSON.parse(_)),await e(h)):(await t.srem(`${s}:index`,h),await t.zrem(m,h))}return w}const[r,i]=a,o=await t.smembers(`${s}:field:${r}:${i}`),f=[];for(const l of o){const w=await t.hget(`${s}:${l}`,"data");w?(f.push(JSON.parse(w)),await e(l)):(await t.srem(`${s}:field:${r}:${i}`,l),await t.srem(`${s}:index`,l),await t.zrem(m,l))}return f},find_one:async(a=null)=>{if(!a)return null;const[r,i]=a,o=await t.smembers(`${s}:field:${r}:${i}`);if(o.length>0){const f=o[0],l=await t.hget(`${s}:${f}`,"data");if(l)return await e(f),JSON.parse(l);await t.srem(`${s}:field:${r}:${i}`,f),await t.srem(`${s}:index`,f),await t.zrem(m,f)}return null},set:async(a=[])=>{const r=await t.smembers(`${s}:index`);if(r.length>0){const i=t.client.multi();for(const f of r)i.del(`${s}:${f}`);const o=await t.client.keys(`${s}:field:*`);for(const f of o)i.del(f);i.del(`${s}:index`),i.del(m),await i.exec()}for(const i of a)await b(c,t,u).add(i)},update:async([a="",r=""],i={})=>{const o=await t.smembers(`${s}:field:${a}:${r}`);if(o.length>0){const f=o[0],l=`${s}:${f}`,w=await t.hget(l,"data");if(w){const h=JSON.parse(w),_={...h,...i};for(const[n,x]of Object.entries(h))n!=="_cache_id"&&await t.srem(`${s}:field:${n}:${x}`,f);$?(await t.hset(l,"data",JSON.stringify(_)),await t.expire(l,$)):await t.hset(l,"data",JSON.stringify(_)),await e(f);for(const[n,x]of Object.entries(_))n!=="_cache_id"&&await t.sadd(`${s}:field:${n}:${x}`,f)}}},remove:async([a="",r=""])=>{const i=await t.smembers(`${s}:field:${a}:${r}`);for(const o of i)await d(o)}}};var S=y;export{S as default};
