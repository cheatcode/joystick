import v from"../app/databases/get_target_database_connection.js";import k from"../lib/generate_id.js";const O=(e="",t={})=>{const p={ttl:null,max_items:null,...t},o=v("cache");return o?.provider==="redis"?b(e,o.connection,p):J(e,p)},J=(e,t={})=>{const{ttl:p,max_items:o}=t,n=r=>{const c=Date.now();return{...r,_cache_created_at:c,_cache_accessed_at:c}},s=()=>{if(!p||!process.caches[e])return;const r=Date.now(),c=p*1e3;process.caches[e]=process.caches[e].filter(w=>r-w._cache_created_at<c)},$=()=>{!o||!process.caches[e]||process.caches[e].length>o&&(process.caches[e].sort((r,c)=>c._cache_accessed_at-r._cache_accessed_at),process.caches[e]=process.caches[e].slice(0,o))},g=r=>(r._cache_accessed_at=Date.now(),r);return{add:(r={})=>{s();const c=n(r);process.caches[e]=[...process.caches[e]||[],c],$()},find:(r=null)=>(s(),(r?process.caches[e]?.filter(w=>w[r[0]]===r[1]):process.caches[e])?.map(g)||[]),find_one:(r=null)=>{s();const c=r?process.caches[e]?.find(w=>w[r[0]]===r[1]):null;return c?g(c):null},set:(r=[])=>{const c=r.map(n);process.caches[e]=c,$()},update:([r="",c=""],w={})=>{s();const a=process.caches[e]?.findIndex((f={})=>f[r]===c);typeof a=="number"&&(process.caches[e][a]={...process.caches[e][a]||{},...w,_cache_accessed_at:Date.now()})},remove:([r="",c=""])=>{process.caches[e]&&(process.caches[e]=process.caches[e].filter((w={})=>w[r]!==c))}}},b=(e,t,p={})=>{const{ttl:o,max_items:n}=p,s=`cache:${e}`,$=`${s}:lru`;if(o){const a=Math.min(o*1e3,3e4);setInterval(async()=>{await g()},a)}const g=async()=>{if(o)try{const a=await t.smembers(`${s}:index`);for(const f of a){const i=`${s}:${f}`;await t.exists(i)||await w(f)}}catch(a){console.warn(`Cache cleanup error for ${e}:`,a)}},r=async()=>{if(!n)return;const a=await t.scard(`${s}:index`);if(a>n){const f=a-n,i=await t.zrange($,0,f-1);for(const m of i)await w(m)}},c=async a=>{n&&await t.zadd($,{score:Date.now(),value:a})},w=async a=>{const f=`${s}:${a}`,i=await t.hget(f,"data");if(i){const m=JSON.parse(i);for(const[l,d]of Object.entries(m))l!=="_cache_id"&&(await t.srem(`${s}:field:${l}:${d}`,a),await t.scard(`${s}:field:${l}:${d}`)===0&&await t.del(`${s}:field:${l}:${d}`))}else{const m=`${s}:field:*`,l=await t.client.keys(m);for(const d of l)await t.sismember(d,a)&&(await t.srem(d,a),await t.scard(d)===0&&await t.del(d))}await t.del(f),await t.srem(`${s}:index`,a),await t.zrem($,a)};return{add:async(a={})=>{a._cache_id||(a._cache_id=k(16));const f=`${s}:${a._cache_id}`;await t.hset(f,"data",JSON.stringify(a)),await t.sadd(`${s}:index`,a._cache_id),await c(a._cache_id);for(const[i,m]of Object.entries(a))i!=="_cache_id"&&await t.sadd(`${s}:field:${i}:${m}`,a._cache_id);o&&await t.expire(f,o),await r()},find:async(a=null)=>{if(!a){const d=await t.smembers(`${s}:index`),u=[];for(const _ of d){const h=await t.hget(`${s}:${_}`,"data");h?(u.push(JSON.parse(h)),await c(_)):(await t.srem(`${s}:index`,_),await t.zrem($,_))}return u}const[f,i]=a,m=await t.smembers(`${s}:field:${f}:${i}`),l=[];for(const d of m){const u=await t.hget(`${s}:${d}`,"data");u?(l.push(JSON.parse(u)),await c(d)):(await t.srem(`${s}:field:${f}:${i}`,d),await t.srem(`${s}:index`,d),await t.zrem($,d))}return l},find_one:async(a=null)=>{if(!a)return null;const[f,i]=a,m=await t.smembers(`${s}:field:${f}:${i}`);if(m.length>0){const l=m[0],d=await t.hget(`${s}:${l}`,"data");if(d)return await c(l),JSON.parse(d);await t.srem(`${s}:field:${f}:${i}`,l),await t.srem(`${s}:index`,l),await t.zrem($,l)}return null},set:async(a=[])=>{const f=await t.smembers(`${s}:index`);if(f.length>0){const i=t.client.multi();for(const l of f)i.del(`${s}:${l}`);const m=await t.client.keys(`${s}:field:*`);for(const l of m)i.del(l);i.del(`${s}:index`),i.del($),await i.exec()}for(const i of a)await b(e,t,p).add(i)},update:async([a="",f=""],i={})=>{const m=await t.smembers(`${s}:field:${a}:${f}`);if(m.length>0){const l=m[0],d=`${s}:${l}`,u=await t.hget(d,"data");if(u){const _=JSON.parse(u),h={..._,...i};for(const[x,y]of Object.entries(_))x!=="_cache_id"&&await t.srem(`${s}:field:${x}:${y}`,l);o?(await t.hset(d,"data",JSON.stringify(h)),await t.expire(d,o)):await t.hset(d,"data",JSON.stringify(h)),await c(l);for(const[x,y]of Object.entries(h))x!=="_cache_id"&&await t.sadd(`${s}:field:${x}:${y}`,l)}}},remove:async([a="",f=""])=>{const i=await t.smembers(`${s}:field:${a}:${f}`);for(const m of i)await w(m)}}};var z=O;export{z as default};
