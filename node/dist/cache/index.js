import v from"../app/databases/get_target_database_connection.js";import k from"../lib/generate_id.js";const O=(s="",t={})=>{const p={ttl:null,max_items:null,...t},o=v("cache");return o?.provider==="redis"?b(s,o.connection,p):J(s,p)},J=(s,t={})=>{const{ttl:p,max_items:o}=t,n=r=>{const f=Date.now();return{...r,_cache_created_at:f,_cache_accessed_at:f}},e=()=>{if(!p||!process.caches[s])return;const r=Date.now(),f=p*1e3;process.caches[s]=process.caches[s].filter(w=>r-w._cache_created_at<f)},$=()=>{!o||!process.caches[s]||process.caches[s].length>o&&(process.caches[s].sort((r,f)=>f._cache_accessed_at-r._cache_accessed_at),process.caches[s]=process.caches[s].slice(0,o))},g=r=>(r._cache_accessed_at=Date.now(),r);return{add:(r={})=>{e();const f=n(r);process.caches[s]=[...process.caches[s]||[],f],$()},find:(r=null)=>(e(),(r?process.caches[s]?.filter(w=>w[r[0]]===r[1]):process.caches[s])?.map(g)||[]),find_one:(r=null)=>{e();const f=r?process.caches[s]?.find(w=>w[r[0]]===r[1]):null;return f?g(f):null},set:(r=[])=>{const f=r.map(n);process.caches[s]=f,$()},update:([r="",f=""],w={})=>{e();const a=process.caches[s]?.findIndex((c={})=>c[r]===f);typeof a=="number"&&(process.caches[s][a]={...process.caches[s][a]||{},...w,_cache_accessed_at:Date.now()})},remove:([r="",f=""])=>{process.caches[s]&&(process.caches[s]=process.caches[s].filter((w={})=>w[r]!==f))}}},b=(s,t,p={})=>{const{ttl:o,max_items:n}=p,e=`cache:${s}`,$=`${e}:lru`;if(o){const a=Math.min(o*1e3,3e4);setInterval(async()=>{await g()},a)}const g=async()=>{if(o)try{const a=await t.smembers(`${e}:index`);for(const c of a){const i=`${e}:${c}`;await t.exists(i)||await w(c)}}catch(a){console.warn(`Cache cleanup error for ${s}:`,a)}},r=async()=>{if(!n)return;const a=await t.client.sCard(`${e}:index`);if(a>n){const c=a-n,i=await t.client.zRange($,0,c-1);for(const m of i)await w(m)}},f=async a=>{n&&await t.zadd($,{score:Date.now(),value:a})},w=async a=>{const c=`${e}:${a}`,i=await t.hget(c,"data");if(i){const m=JSON.parse(i);for(const[l,d]of Object.entries(m))l!=="_cache_id"&&(await t.srem(`${e}:field:${l}:${d}`,a),await t.client.sCard(`${e}:field:${l}:${d}`)===0&&await t.del(`${e}:field:${l}:${d}`))}else{const m=`${e}:field:*`,l=await t.client.keys(m);for(const d of l)await t.client.sIsMember(d,a)&&(await t.srem(d,a),await t.client.sCard(d)===0&&await t.del(d))}await t.del(c),await t.srem(`${e}:index`,a),await t.zrem($,a)};return{add:async(a={})=>{a._cache_id||(a._cache_id=k(16));const c=`${e}:${a._cache_id}`;await t.hset(c,"data",JSON.stringify(a)),await t.sadd(`${e}:index`,a._cache_id),await f(a._cache_id);for(const[i,m]of Object.entries(a))i!=="_cache_id"&&await t.sadd(`${e}:field:${i}:${m}`,a._cache_id);o&&await t.expire(c,o),await r()},find:async(a=null)=>{if(!a){const d=await t.smembers(`${e}:index`),u=[];for(const _ of d){const h=await t.hget(`${e}:${_}`,"data");h?(u.push(JSON.parse(h)),await f(_)):(await t.srem(`${e}:index`,_),await t.zrem($,_))}return u}const[c,i]=a,m=await t.smembers(`${e}:field:${c}:${i}`),l=[];for(const d of m){const u=await t.hget(`${e}:${d}`,"data");u?(l.push(JSON.parse(u)),await f(d)):(await t.srem(`${e}:field:${c}:${i}`,d),await t.srem(`${e}:index`,d),await t.zrem($,d))}return l},find_one:async(a=null)=>{if(!a)return null;const[c,i]=a,m=await t.smembers(`${e}:field:${c}:${i}`);if(m.length>0){const l=m[0],d=await t.hget(`${e}:${l}`,"data");if(d)return await f(l),JSON.parse(d);await t.srem(`${e}:field:${c}:${i}`,l),await t.srem(`${e}:index`,l),await t.zrem($,l)}return null},set:async(a=[])=>{const c=await t.smembers(`${e}:index`);if(c.length>0){const i=t.client.multi();for(const l of c)i.del(`${e}:${l}`);const m=await t.client.keys(`${e}:field:*`);for(const l of m)i.del(l);i.del(`${e}:index`),i.del($),await i.exec()}for(const i of a)await b(s,t,p).add(i)},update:async([a="",c=""],i={})=>{const m=await t.smembers(`${e}:field:${a}:${c}`);if(m.length>0){const l=m[0],d=`${e}:${l}`,u=await t.hget(d,"data");if(u){const _=JSON.parse(u),h={..._,...i};for(const[x,y]of Object.entries(_))x!=="_cache_id"&&await t.srem(`${e}:field:${x}:${y}`,l);o?(await t.hset(d,"data",JSON.stringify(h)),await t.expire(d,o)):await t.hset(d,"data",JSON.stringify(h)),await f(l);for(const[x,y]of Object.entries(h))x!=="_cache_id"&&await t.sadd(`${e}:field:${x}:${y}`,l)}}},remove:async([a="",c=""])=>{const i=await t.smembers(`${e}:field:${a}:${c}`);for(const m of i)await w(m)}}};var z=O;export{z as default};
